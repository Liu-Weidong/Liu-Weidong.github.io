<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[软件架构]]></title>
    <url>%2F%E3%80%90%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E3%80%91%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[引言 软件架构（Software Architecture）是一系列相关的抽象模式，用于指导大型软件系统各个方面的设计。软件架构是一个系统的草图。软件架构描述的对象是直接构成系统的抽象组件。各个组件之间的连接则明确和相对细致地描述组件之间的通讯。在实现阶段，这些抽象组件被细化为实际的组件，如具体某个类或对象。轻量级JavaEE（Struts+Spring+Hibernate）重量级JavaEE（JSF+EJB+JPA） 架构模式是描述软件系统里的基本的结构组织或纲要。从定义上来看，它是在指导我们如何组织代码，是一种具有指导意义的思想，如解决系统的数据与显示分离的问题，AOP、IOC、ORM、MVC等。 框架是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法；另一种定义认为，框架是可被应用开发者定制的应用骨架。前者是从应用方面而后者是从目的方面给出的定义。Struts、MyBatis等。 设计模式是一套被反复使用、多数人知道的、经过分类编目的、代码设计经验的总结。从定义上看，它涉及到了代码级别，侧重于解决实际的现实问题。 分层架构分层架构（layered architecture）是最常见的软件架构，也是事实上的标准架构。将软件分成若干个水平层，每一层都有清晰的角色和分工，不需要知道其他层的细节。层与层之间通过接口通信。虽然没有明确约定，软件一定要分成多少层，但是四层的结构最常见。 表现层（presentation）：用户界面，负责视觉和用户互动 业务层（business）：实现业务逻辑 持久层（persistence）：提供数据，SQL语句放在这一层 数据层（database）：保存数据 事件驱动架构事件驱动架构（Event Driven Architecture，EDA）一个事件驱动框架（EDA）定义了一个设计和实现一个应用系统的方法学，在这个系统里事件可传输于松散耦合的组件和服务之间。 微核架构微核架构（microkernel architecture）又称为”插件架构”（plug-in architecture），指的是软件的内核相对较小，主要功能和业务逻辑都通过插件实现。内核（core）通常只包含系统运行的最小功能。插件则是互相独立的，插件之间的通信，应该减少到最低，避免出现互相依赖的问题。优点： 良好的功能延伸性（extensibility），需要什么功能，开发一个插件即可 功能之间是隔离的，插件可以独立的加载和卸载，使得它比较容易部署 可定制性高，适应不同的开发需要 可以渐进式地开发，逐步增加功能 缺点： 扩展性（scalability）差，内核通常是一个独立单元，不容易做成分布式 开发难度相对较高，因为涉及到插件与内核的通信，以及内部的插件登记机制 微服务架构微服务架构（microservices architecture）是服务导向架构（service-oriented architecture，缩写 SOA）的升级。每一个服务就是一个独立的部署单元（separately deployed unit）。这些单元都是分布式的，互相解耦，通过远程通信协议（比如REST、SOAP）联系。 云架构云结构（cloud architecture）主要解决扩展性和并发的问题，是最容易扩展的架构。它的高扩展性，主要原因是没使用中央数据库，而是把数据都复制到内存中，变成可复制的内存数据单元。然后，业务处理能力封装成一个个处理单元（prcessing unit）。访问量增加，就新建处理单元；访问量减少，就关闭处理单元。由于没有中央数据库，所以扩展性的最大瓶颈消失了。由于每个处理单元的数据都在内存里，最好要进行数据持久化。这个模式主要分成两部分：处理单元（processing unit）和虚拟中间件（virtualized middleware）。 处理单元：实现业务逻辑 虚拟中间件：负责通信、保持sessions、数据复制、分布式处理、处理单元的部署。]]></content>
      <categories>
        <category>软件架构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[android-框架-图片加载]]></title>
    <url>%2Fandroid-%E6%A1%86%E6%9E%B6-%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[Fresco引言2015年3月Facebook开源的图片框架。https://www.fresco-cn.org/docs/index.html Fresco项目https://github.com/facebook/fresco 工作原理源码解析优缺点优点：缺点： 框架大，影响APK大小 使用繁琐 Glide引言2014年Google员工提出。 Glide项目https://github.com/bumptech/glide 工作原理源码解析优缺点Picasso引言2013年2月Square开源的项目。 Picasso项目https://github.com/square/picasso 工作原理源码解析优缺点universal-image-loader引言2011年9月nostra13开发。 universal-image-loader项目https://github.com/nostra13/Android-Universal-Image-Loader 工作原理源码解析优缺点]]></content>
      <categories>
        <category>android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-框架-网络请求]]></title>
    <url>%2Fandroid-%E6%A1%86%E6%9E%B6-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[引言网络请求框架本质上是将网络请求方法封装好的类库，实现异步请求和处理数据，从而实现整个网络请求模块的功能。 RetrofitOkHttpVolley引言Volley是2013年Google I/O上发布的一款Android平台上的网络通信库。适合数据量大，需要频繁通信的网络操作。不适用文件的上传下载操作。 Android-Async-HttpAndroid源生网络请求Apache HttpClient已经不推荐使用，6.0上被删除。Google推荐在Android上使用HttpURLConnection HttpURLConnection问题 没有针对异步调用进行封装 没有线程池，网络缓存，不能重复利用请求，性能不佳 没有json解析框架]]></content>
      <categories>
        <category>android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-框架-ARouter]]></title>
    <url>%2Fandroid-%E6%A1%86%E6%9E%B6-ARouter%2F</url>
    <content type="text"><![CDATA[A framework for assisting in the renovation of Android componentization.帮助Android APP进行组件化改造的路由框架——支持模块间的路由、通信、解耦 背景随着项目的发展，功能模块增多，无法避免面临以下问题： 项目编译时间变长 代码牵一发而动全身，项目维护难度增大 耦合代码与业务造成冲突，极大降低开发效率 组件化应运而生： 使功能模块可以独立开发、编译调试，降低项目编译时间提高开发效率 使功能模块间进行解耦 组件化问题：代码解耦的同时阻断了彼此的通信。Android原生可以实现，但是造成代码耦合，违背组件化目的，有没有简单易管理的通信方案？ARouter应运而生 ARouter项目https://github.com/alibaba/ARouter模块：arouter-apiarouter-compilerarouter-registerarouter-idea-plugin：使用IDE插件导航到目标类，Android Studio插件市场中搜索ARouter Helper 应用场景 外部URL映射到内部页面，以及参数传递与解析 跨模块页面跳转，模块间解耦 拦截跳转过程，处理登录、埋点等逻辑 跨模块API调用，通过控制反转来做组件解耦 工作原理源码解析源码分为arouter-annotation、arouter-api、arouter-compiler三部分 arouter-annotation声名注解： @Autowired @Interceptor @Route 123456789101112131415161718192021222324252627282930@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.CLASS)public @interface Route &#123; /** * Path of route */ String path(); /** * Used to merger routes, the group name MUST BE USE THE COMMON WORDS !!! */ String group() default ""; /** * Name of route, used to generate javadoc. */ String name() default ""; /** * Extra data, can be set by user. * Ps. U should use the integer num sign the switch, by bits. 10001010101010 */ int extras() default Integer.MIN_VALUE; /** * The priority of route. */ int priority() default -1;&#125;]]></content>
      <categories>
        <category>android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>ARouter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-安全]]></title>
    <url>%2Fandroid-%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[混淆反编译加固梆梆加固、爱加密、娜迦、360加固保、腾讯加固、百度加固 常见APP漏洞及风险 静态破解：ApkTool、dex2jar、jd-gui、DDMS、签名工具 二次打包 本地储存数据窃取 界面截取 输入法攻击 协议抓取]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-性能优化]]></title>
    <url>%2Fandroid-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[布局优化 include标签共享布局 ViewStub标签实现延迟加载：页面是从服务端获取数据进行展现的。 merge标签减少布局层次 尽量使用CompoundDrawable 使用Lint 代码优化 不要做冗余的工作。 尽量避免进行过多的内存分配操作。 Java中引用方式 强引用 软引用：当内存空间不足时，对象才被回收。 弱引用：不论当前内存空间是否不足，都回收。 虚引用：本质只是标记，跟踪对象被垃圾回收的活动。 避免使用非必要的对象代码重构电量优化网络优化避免DNS解析DNS是域名系统，根据应用请求所用的域名URL去网络映射表中查找对应IP地址，可能需要上百毫秒，可能存在DNS劫持的危险。 合并网络请求一次完整的HTTP请求，首先进行DNS查找，接着通过TCP三次握手，从而建立连接；如果是HTTPS请求，还需要经过TLS握手成功后连接才建立。 离线缓存Android中，典型的是使用LruCache实现内存缓存，DiskLruCache实现外存缓存。 压缩数据大小减少网络上面传输的数据，对于客户端来说，可以对发送给服务端的数据进行gzip压缩；同时选用更优的数据传输格式。 合理选择超时策略监听ConnectivityManager.CONNECTIVITY_ACTION变化获取最新的网络类型。 使用CDNCDN全称是内容分发网络，基本思想是尽可能避开网络上可能影响数据传输速度和稳定性的环节，从而实现更快、更稳定的数据传输。CDN加速能够缓解电信核心网络延迟带来的影响。 图片优化图片格式JPEG、PNG、GIF、BMP、WebP（Android 4.0）应用开发中能够使用的编码格式只有三种：JPEG、PNG、WebP，图片格式可以通过查看Bitmap类的CompressFormat确定。应用层使用GIF格式，需引入第三方库。 JPEG：有损压缩图像标准格式，不支持透明和多帧动画。 PNG：无损压缩图片格式，支持完整的透明通道，从图像处理领域讲，JPEG只有RGB三个通道，而PNG有ARGB四个通道。 GIF：古老的图片格式，诞生于1987。支持多帧动画。 WebP：Google在2010年发布，支持有损和无损压缩、支持完整的透明通道、也支持多帧动画。 图片压缩PNG图片压缩工具： 无损压缩ImageOptim：通过优化PNG压缩参数，移除冗余元数据以及非必需的颜色设置文件等方式。 有损压缩ImageAlpha 有损压缩TinyPNG PNG/JPEG转换为WebP：4.0以上直接使用，以下通过第三方库Webp-android-backport实现。Google测试，无损压缩后的WebP比PNG 文件少了45%的文件大小，通过其他压缩工具之后，依然减少约28%的文件大小。WebP转换的工具可以选择智图和iSparta等。 尽量使用NinePatch格式的PNG图：.9.png 图片缓存开源框架LeakCanary]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【阅读】算法导论-第三版]]></title>
    <url>%2F%E3%80%90%E9%98%85%E8%AF%BB%E3%80%91%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E7%AC%AC%E4%B8%89%E7%89%88%2F</url>
    <content type="text"><![CDATA[算法基础排序堆排序堆排序的时间复杂度是O(nlgn)。 快速排序线性时间排序数据结构基本数据结构栈和队列栈和队列都是动态集合，且在其上进行DELETE操作所移除的元素是预先设定的。在栈（stack）中，被删除的是最近插入的元素：栈实现的是一种后进先出（last-in，first-out，LIFO）策略。类似的，队列（queue）中，被删去的总是在集合中存在时间最长的那个元素：队列实现的是一种先进先出（first-in，first-out，FIFO）策略。 栈上的INSERT操作称为压入（PUSH），而无元素参数的DELETE操作称为弹出（POP）。 队列 链表散列表二叉搜索树红黑树高级数据结构B树图算法基本的图算法最小生成树]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-框架-view-图表]]></title>
    <url>%2Fandroid-%E6%A1%86%E6%9E%B6-view-%E5%9B%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[MPAndroidChartHelloChartsWilliamChart]]></content>
      <categories>
        <category>android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[架构模式_MVC-MVP-MVVM-MVI]]></title>
    <url>%2F%E3%80%90%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E3%80%91MVC-MVP-MVVM-MVI%2F</url>
    <content type="text"><![CDATA[小序框架面向于一系列相同行为代码的重用，而设计则面向的是一系列相同结构代码的重用。简而言之：框架是大智慧，用来对软件设计进行分工；设计模式是小技巧，对具体问题提出解决方案，以提高代码复用率，降低耦合度。 对待框架演变的态度：所谓真理只是在特定领域条件下成立的教条理论罢了。 MVCModel-View-Controller（模型-视图-控制器）MVC是一种框架模式而非设计模式，GOF把MVC看作是3种设计模式：观察者模式、策略模式与组合模式的合体，而且其核心在观察者模式，也就是一个基于发布/订阅者模型的框架。 经典MVC1978年由Trygve Reenskaug在Smalltalk-80系统上首次提出。MVC本质是分层解耦，将表现层与逻辑进行分离。 Model：Model可以是一个独立的对象，也可以是一系列对象的集合体。 View：View是Model中一些重要数据在视觉上的体现。 Controller：Controller用于连接User和System，比如当Controller接收到用户的输出时，会将其转换成合适的事件消息，并将该事件消息传递给一个或多个View。 Application Model MVCModel21998年，Model2被首次提出。Model2被应用于Web开发中，将JavaBean、JSP、Servlet对应于MVC的三个部分。Model2改进了事件流向。 User –&gt; Controller –&gt; Model –&gt; Controller –&gt; View –&gt; UserView与Model不再有耦合，接近于MVP，不同的是MVP捕获用户交互请求的是View而不是Controller。 MVPModel-View-Presenter（数据层-UI层-业务逻辑层） MVVMModel-View-ViewModel2005年被微软的WPF和Silverlight的架构师John Gossman提出，并且应用在微软的项目开发中，前身是Martin Fowler在2004年发表的Presentation Model（PM）设计模式。 DataBinding配置12345android &#123; dataBinding &#123; enabled true &#125;&#125; 布局结构首先根节点为layout；其次，布局文件中声名所使用到的数据实体类；然后才是传统布局节点。123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;!--data节点声名数据模型--&gt; &lt;data&gt; &lt;variable name="userModel" type="com.test.demo.testdemo.UserModel" /&gt; &lt;/data&gt; &lt;!--传统布局--&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;Button android:layout_width="match_parent" android:layout_height="50dp" android:text="@&#123;userModel.btnText&#125;" /&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 数据绑定12345678@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); DataBindingTestBinding binding = DataBindingUtil.setContentView(this, R.layout.data_binding_test); UserModel model = new UserModel(); model.setBtnText("中国"); binding.setUserModel(model);&#125; MVIModel-View-Intent（数据层-UI层-业务逻辑层） Model：代表一种状态。]]></content>
      <categories>
        <category>软件架构</category>
      </categories>
      <tags>
        <tag>MVC</tag>
        <tag>MVP</tag>
        <tag>MVVM</tag>
        <tag>MVI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-view-滑动]]></title>
    <url>%2Fandroid-view-%E6%BB%91%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[滑动是实现绚丽的自定义控件的基础。 基础知识MotionEvent事件类型 ACTION_DOWN：手指刚接触屏幕 ACTION_MOVE：手指在屏幕上移动 ACTION_UP：手指从屏幕上松开的一瞬间 getX/getY：相对于当前View左上角的坐标getRawX/getRawY：相对于手机屏幕左上角的坐标 TouchSlop系统所能识别的滑动最小距离。常量值，与设备有关。1ViewConfiguration.get(getContext()).getScaledTouchSlop() VelocityTracker速度追踪，手指在滑动过程中的速度（一段时间内手指滑过的像素数）。123456789101112// onTouchEvent方法中使用VelocityTracker velocityTracker = VelocityTracker.obtain();velocityTracker.addMovement(event);// 滑动速度velocityTracker.computeCurrentVelocity(1000);int xVelocity = (int) velocityTracker.getXVelocity();int yVelocity = (int) velocityTracker.getYVelocity();// 重置回收velocityTracker.clear();velocityTracker.recycle(); 滑动冲突]]></content>
      <categories>
        <category>android</category>
        <category>view</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-view-事件分发]]></title>
    <url>%2Fandroid-view-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%2F</url>
    <content type="text"><![CDATA[点击事件的分发，其实就是对MotionEvent事件的分发过程，产生MotionEvent后，系统需要把这个事件传递给一个具体的View，而这个传递的过程就是分发过程。 事件传递的三个阶段： 分发（Dispatch）：事件分发对应dispatchTouchEvent方法。方法返回值true表示事件被当前视图消费掉，不再继续分发事件；方法返回值是super.dispatchTouchEvent表示继续分发该事件。如果当前视图是ViewGroup及其子类，则会调用onInterceptTouchEvent方法判定是否拦截该事件。 拦截（Intercept）：事件拦截对应onInterceptTouchEvent方法，这个方法只在ViewGroup及其子类中存在，在View和Activity中是不存在的。返回true，不会继续传递给子View，返回false或父类同名方法，则事件会继续传递给子View。 消费（Consume）：事件的消费对应着onTouchEvent。方法返回值true表示当前视图可以处理对应的事件，事件不会向上传递给父视图；返回值为false表示当前视图不处理这个事件，事件会传递给父视图的onTouchEvent方法进行处理。]]></content>
      <categories>
        <category>android</category>
        <category>view</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-view-工作原理]]></title>
    <url>%2Fandroid-view-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[UI层级Android UI层级如下图： Activity是Android的四大组件之一，与用户交互的窗口。 Window是抽象类，具体实现类是PhoneWindow。Android中的视图都是附加在Window上的，因此Window实际是View的直接管理者，Window和View通过ViewRootImpl来建立联系。Activity中的方法setContentView也是通过Window来完成的。（接口WindowManager继承ViewManager） Activity对象被创建完毕后，会将DecorView添加到Window中，同时会创建ViewRootImpl对象，并将ViewRootImpl对象和DecorView建立关联。 基础知识MeasureSpec32位int值，高2位表示SpecMode测量模式，低30位表示SpecSize某种测量模式下的规格大小。 SpecMode UNSPECIFIED：不指定测量模式。父视图没有限制子视图的大小，子视图可以是想要的任何尺寸。 EXACTLY：精确测量模式。View的测量值就是SpecSize。match_parent AT_MOST：最大值模式。子视图的尺寸可以是不超过父视图允许的最大尺寸的任何尺寸。wrap_content LayoutParamsView绘制流程Measure（测量） [View的测量过程] View的measure（final，子类不能重写该方法）方法进行测量，measure方法会调用View的onMeasure方法。源码如下：123456789101112131415161718192021222324252627282930protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125;/** * Utility to return a default size. Uses the supplied size if the * MeasureSpec imposed no constraints. Will get larger if allowed * by the MeasureSpec. * * @param size Default size for this view * @param measureSpec Constraints imposed by the parent * @return The size this view should be. */public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; [ViewGroup的测量过程] ViewGroup测量完自身后，还会遍历调用所有子View的measure方法。ViewGroup为抽象类，因此没有重写View的onMeasure方法，但是提供了方法measureChildren。源码如下：12345678910111213141516171819202122232425262728293031323334353637383940/** * Ask all of the children of this view to measure themselves, taking into * account both the MeasureSpec requirements for this view and its padding. * We skip children that are in the GONE state The heavy lifting is done in * getChildMeasureSpec. * * @param widthMeasureSpec The width requirements for this view * @param heightMeasureSpec The height requirements for this view */protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125;&#125;/** * Ask one of the children of this view to measure itself, taking into * account both the MeasureSpec requirements for this view and its padding. * The heavy lifting is done in getChildMeasureSpec. * * @param child The child to measure * @param parentWidthMeasureSpec The width requirements for this view * @param parentHeightMeasureSpec The height requirements for this view */protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; 注意：测量完成后，通过getMeasuredWidth与getMeasuredHeight获取宽高。onMeasure方法中可能不准确，在onLayout方法中获取比较靠谱。 Activity中获取View宽高的方式：方法1：view.post(runnable)，将runnable添加到消息队列的末尾，等待Looper调用时，View完成初始化。方法2：Activity中重写方法onWindowFocusChanged。弊端：页面焦点改变时，该方法就会被调用。方法3：ViewTreeObserver - onGlobalLayoutListener，View树的状态发生改变或内部View可见性发生改变时，onGlobalLayout方法将被回调。弊端：onGlobalLayout会被多次调用。方法4：measure(int widthMeasureSpec, int heightMeasureSpec) Layout（布局）Draw（绘制）]]></content>
      <categories>
        <category>android</category>
        <category>view</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【阅读】TCP-IP详解]]></title>
    <url>%2F%E3%80%90%E9%98%85%E8%AF%BB%E3%80%91TCP-IP%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[概述互联网地址互联网上的每个接口必须有一个唯一的Internet地址（IP地址，32bit）。 链路层TCP/IP支持多种不同的链路层协议，这取决于网络所使用的硬件，如以太网、令牌环网、FDDI（光纤分布式数据接口）及RS-232串行线路等。 IP（网际协议）Ping程序“ping”源于声呐定位操作。Ping程序由Mike Muuss编写，目的是测试另一台主机是否可达。 UDP（用户数据报协议）引言UDP是一个简单的面向数据报的运输层协议：进程的每个输出操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据报。UDP不提供可靠性。 DNS（域名系统）引言DNS（Domain Name System，域名系统）是一种用于TCP/IP应用程序的分布式数据库，它提供主机名称和IP地址之间的转换及有关电子邮件的选路信息。注意：网络信息中心NIC负责分配顶级域和委派其他指定地区域的授权机构。 基础顶级域名分为三个部分： arpa一个用作地址到名字转换的特殊域。 7个3字符长的普通域。 2个字符的域是基于ISO3166中定义的国家代码，称为国家域。 域 描述 com 商业组织 edu 教育机构 gov 其他美国政府部门 int 国际组织 mil 美国军事网点 net 网络 org 其他组织 报文格式TCP（传输控制协议）TCP提供一种面向连接的、可靠的字节流服务。TCP通过下列方式提供可靠性： 应用数据被分割成TCP认为最适合发送的数据块。 TCP连接的建立与终止TCP超时与重传]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>TCP|IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[版本控制系统详解]]></title>
    <url>%2F%E3%80%90%E5%88%A9%E5%99%A8%E3%80%91%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[工欲善其事，必先利其器。——《论语·卫灵公》 版本控制系统（VCS）版本控制系统（Version Control System），是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 本地版本控制系统集中化的版本控制系统（CVCS）如CVS、Subversion、Perforce等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 分布式版本控制系统分布式版本控制系统（Distributed Version Control System，DVCS），如Git、Mercurial、Bazaar、Darcs等，客户端并不只是提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 CVSSubversion简介Subversion（SVN）是一个自由开源的版本控制系统，相对于CVS，采用了分支管理系统，它的设计目标就是取代CVS。2000年，CollabNet开始寻找CVS替代产品的开发人员。 TortoiseSVNBitKeeperGit简介分布式版本控制系统 Workspace：工作区 Index/Stage：暂存区 Repository：仓库区（本地仓库） Remote：（远程仓库） Git命令【git init】在当前目录新建一个Git代码库【git init [project-name]】【git clone url】下载一个项目和整个代码历史【git branch】列出所有本地分支【git branch -r】列出所有远程分支【git status】显示有变更的文件【git log】显示当前分支的版本历史【git pull [remote] [branch]】取回远程仓库的变化，并与本地分支合并【git pull origin master –allow-unrelated-histories】【git push [remote] [branch]】上传本地分支到远程仓库【git push [remote] -force】强行推送当前分支到远程仓库，即使有冲突 可视化界面软件SourceTree拥有可视化界面的项目版本控制软件，适用于git项目管理。分支共有5种类型： master：最终发布版本，整个项目中有且只有一个 develop：项目的开发分支，原则上项目中有且只有一个 feature：功能分支，用于开发一个新的功能 release：预发布版本，介于master与develop之间的版本，主要用于测试 hotfix：修复补丁，用于修复master上的bug，直接作用于master 在线代码仓库GitHubGitHub是在线的基于Git的代码托管服务。GitHub是2008年由Ruby on Rails编写而成。 GitLabGitLab是利用Ruby on Rails开源的版本管理系统，实现一个自托管的Git项目仓库，可通过Web界面进行访问公开的或私人项目。依赖组件：Ruby 1.9.3+，MySQL，Git，Redis，sidekiq BitbucketGitEEMercurialMercurial是一种轻量级分布式版本控制系统，采用Python语言实现，易于学习和使用，扩展性强。基于GNU General Public License（GPL）授权的开源项目。]]></content>
      <categories>
        <category>利器</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【阅读】深入理解计算机系统]]></title>
    <url>%2F%E3%80%90%E9%98%85%E8%AF%BB%E3%80%91%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[计算机系统漫游硬件组成 总线：贯穿整个系统的是一组电子管道，称作总线，携带信息字节并负责在各个部件间传递。 I/O设备：输入/输出设备是系统与外部世界的联系通道。每个I/O设备都通过一个控制器或适配器与I/O总线相连。 主存：主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存取存储器（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引）。 CPU，简称处理器，是解释（或执行）存储在主存中指令的引擎。运算器：运算器又称算术逻辑单元（ALU，Arithmetic Logic Unit）。 【典型系统的硬件组成】【存储器层次结构】 并发和并行数字计算机的整个历史中，有两个需求是驱动进步的持续动力：一个是我们想要计算机做得更多，另一个是我们想要计算机运行得更快。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[android-框架-RxJava]]></title>
    <url>%2Fandroid-%E6%A1%86%E6%9E%B6-RxJava%2F</url>
    <content type="text"></content>
      <categories>
        <category>android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-框架-Log]]></title>
    <url>%2Fandroid-%E6%A1%86%E6%9E%B6-Log%2F</url>
    <content type="text"><![CDATA[Logger引言Logger项目工作原理源码解析]]></content>
      <categories>
        <category>android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建工具-Gradle]]></title>
    <url>%2F%E3%80%90%E5%88%A9%E5%99%A8%E3%80%91%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7-Gradle%2F</url>
    <content type="text"><![CDATA[GradleGradleAndroid Gradle plugin2013年5月，谷歌发布Android Studio（基于JetBrains的IntelliJ IDEA），并对Gradle进行了支持。Gradle构建脚本的书写没有基于传统的XML文件，而是基于Groovy的领域专用语言（DSL）。 Gradle构建Android项目时，需要创建一个构建脚本，通常称为build.gradle。 Gradle有约定优于配置的原则，即为设置和属性提供默认值。 GroovyGroovyGroovy是一种适用于Java虚拟机的动态语言。 类和成员变量def：声名变量 方法在Groovy中，方法的最后一行通常默认返回，即使没有使用return关键字。 ClosuresClosures是匿名代码块，可以接受参数和返回值。 集合List和Map123456List list = [1, 2, 3, 4]list.each() &#123; element -&gt; println element&#125;Map prices = [apple:10, car:100] 123apply plugin: 'com.android.application'// apply()是Project类的一个方法。参数是key为plugin，value为com.android.application的Map。project.apply([plugin: 'com.android.application']) 项目和任务每一次构建都包括至少一个项目，每一个项目又包括一个或多个任务。每个build.gradle文件都代表着一个项目，任务定义在构建脚本里。当初始化构建过程时，Gradle会基于build文件组装项目和任务对象。一个任务对象包含一系列动作对象，这些动作对象之后会按顺序执行。一个单独的动作对象就是一个待执行的代码块，它和Java中的方法类似。构建生命周期 初始化 配置 执行 Gradle Wrapper项目根目录，在terminal上运行gradlew -v或在命令行上运行gradlew.bat -v检查项目中的Gradle Wrapper是否可用。https://gradle.org/releases/ gradle文件 settings.gradle：位于项目的根目录 1include ':app' build.gradle：顶级构建文件，位于项目的根目录 1234567891011121314151617buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; // Gradle的Android插件 classpath 'com.android.tools.build:gradle:2.3.0' &#125;&#125;allprojects &#123; repositories &#123; jcenter() google() &#125;&#125; build.gradle：模块级构建文件，位于Module的根目录，可以覆盖顶层build.gradle中的任何属性。 12345678910111213141516171819202122232425262728293031323334353637android &#123; compileSdkVersion 27 buildToolsVersion '27.0.3' defaultConfig &#123; applicationId "com.test" minSdkVersion 14 targetSdkVersion 27 versionCode 1 versionName "1.0.0" &#125; signingConfigs &#123; debug &#123; storeFile file("./doc/debug/debug.keystore") storePassword "android" keyAlias "androiddebugkey" keyPassword "android" &#125; &#125; buildTypes &#123; debug &#123; minifyEnabled false signingConfig signingConfigs.debug &#125; release &#123; minifyEnabled true signingConfig signingConfigs.debug proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125;dependencies &#123;&#125; applicationId：定义在manifest文件中的package，继续用在你的源代码和R类中，而之前被用作设备和Google Play唯一标识的package name，现在则被称之为applicationId。ext：Gradle允许在Project对象上添加额外属性。这意味着任何build.gradle文件都能定义额外的属性，添加额外属性需要通过ext代码块。顶层构建文件添加如下代码块：1234ext &#123; compileSdkVersion = 23 buildToolsVersion = '23.0.3'&#125; 模块层的构建文件使用rootProject获取属性：1234android &#123; compileSdkVersion rootProject.ext.compileSdkVersion buildToolsVersion rootProject.ext.buildToolsVersion&#125; BuildConfigSDK工具版本升级到17之后，构建工具都会生成一个叫作BuildConfig的类，该类包含一个按照构建类型设置值得DEBUG常量。1234567891011android &#123; buildTypes &#123; debug &#123; buildConfigField "boolean","IS_LOG","true" buildConfigField "String","URL","\"http://test.example.com\"" &#125; release &#123; buildConfigField "boolean","IS_LOG","false" &#125; &#125;&#125; 字符串值必须用转义双引号括起来，这样才会生成实际意义上的字符串。Java代码中可以这样用BuildConfig.IS_LOG和BuildConfig.URL buildConfigField resValue 依赖管理远程仓库12345repositories &#123; maven&#123; url "自己的服务器地址" &#125;&#125; 本地仓库12345repositories &#123; maven&#123; url "../test" &#125;&#125; 通过使用flatDirs添加一个常用文件夹作为仓库。12345repositories &#123; flatDir &#123; dirs 'libs', '../Framework/libs' &#125;&#125; 本地依赖https://developer.android.google.cn/studio/build/dependencies.html12345678dependencies &#123; // 依赖单个JAR文件 compile files('libs/test.jar') // 依赖所有文件 compile fileTree('libs') // 依赖指定文件格式，如JAR compile fileTree(dir: 'libs', include: ['*.jar'])&#125; 原生依赖库.so文件：在模块的main目录下新建jniLibs文件夹，然后为每个平台（armeabi、mips、x86）创建子文件夹。如果此约定不生效，可以在构建文件中设置相关设置：12345android &#123; sourceSets.main &#123; jniLibs.srcDir 'src/main/libs' &#125;&#125; 依赖项目：123dependencies &#123; compile project(':Test')&#125; .aar文件： 添加依赖仓库文件夹 添加依赖，如下 123dependencies &#123; compile(name: 'aarName', ext: 'aar')&#125; 语义化版本将依赖添加到JCenter等依赖仓库时，约定遵循了一套版本化规则，称为语义化版本。版本数字的格式一般为major.minor.patch 当做不兼容的API变化时，major版本增加。 当以向后兼容的方式添加功能时，minor版本增加。 当修复一些bug时，patch版本增加。 基于以上规则，可以添加动态化版本。+ 构建varianthttps://developer.android.google.cn/studio/build/build-variants.html 构建类型https://developer.android.google.cn/studio/build/build-variants.html#build-types12345678910111213141516171819android &#123; buildTypes &#123; debug &#123; &#125; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; // 用已有的构建类型属性初始化新的构建类型 staging.initWith(buildTypes.debug) staging &#123; applicationIdSuffix ".staging" versionNameSuffix "-staging" &#125; &#125;&#125; 可以根据构建类型来添加依赖。如debugCompile ‘com.android.support:***:1.0.0’ product flavorhttps://developer.android.google.cn/studio/build/build-variants.html#product-flavors1234567891011android &#123; productFlavors &#123; free &#123; &#125; paid &#123; &#125; &#125;&#125; 签名配置应用签名123456789101112android &#123; signingConfigs &#123; staging.initWith(signingConfigs.debug) release &#123; storeFile file("../key/debug.keystore") storePassword "android" keyAlias "androiddebugkey" keyPassword "android" &#125; &#125;&#125; 加速构建Jack和JillJack（Java Android Compiler Kit）是一个新的Android构建工具链，其可以直接编译Java源码为Android Dalvik的可执行格式。它有自己的.jack依赖库格式，也采用了打包和缩减。Jill（Jack Intermediate Library Linker）是一个可以将.aar和.jar文件转换成.jack依赖库的工具。useJack = true]]></content>
      <categories>
        <category>利器</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven]]></title>
    <url>%2F%E3%80%90%E5%88%A9%E5%99%A8%E3%80%91Maven%2F</url>
    <content type="text"><![CDATA[Maven简介Eclipse + Ant组合的时候，引入库都是下载jar包或aar包放到lib目录下，然后添加引用。!!!不能实时更新。Android Studio + Gradle组合中gradle中提供了可以从远端拉取jar包和aar包引入本地。Maven仓库分为两类：本地仓库和远程仓库。 远程仓库又分为：中央仓库、Nexus和其他公共库。 本地仓库就是本地存放jar包的位置，Maven的本地仓库在最开始的时候并不会创建，而是第一次启动Maven时，在当前用户的文件夹下建立一个.m2文件，其中存放Maven本地仓库的所有jar包。 配置http://maven.apache.org/download.cgi环境变量 MAVEN_HOME——安装路径 PATH——%MAVEN_HOME%\bin; 【mvn -v】命令行输入，查看配置是否成功。 服务源 JCenter托管在Bintray上面的Maven仓库。 Maven Central托管在Sonatype上面的Maven仓库。 JitPack JCenter优点: 基于CDN分布函数库，JCenter提供了更快的下载速度。 JCenter是最大的Java仓库，可以说Maven Central是JCenter的一个子集，托管在Maven Central中的函数库，几乎都托管在JCenter上面。 上传简单，Bintray的用户界面对用户友好。 获取函数库的原理完整的函数库依赖字符串包含三部分：GROUP_ID:ARTIFACT_ID:VERSIONGradle根据依赖配置，向Maven Repository服务器查询是否存在该版本的函数库，如果存在，则会根据服务器类型拼接下载请求url。 JCenter：http://jcenter.bintray.com/... Maven Central：https://oss.sonatype.org/content/repositories/releases... Maven私服私服是架设在局域网内的远程仓库，目的是代理远程仓库及部署第三方构件。 Sonatype Nexus搭建默认端口：8081http://127.0.0.1:8081/http://localhost:8081/默认配置文件：C:\swTools\nexus-3.13.0-01\etc\nexus-default.properties默认登录：admin/admin123 常用命令【nexus.exe/install】安装nexus为系统服务【nexus.exe/uninstall】卸载nexus为系统服务【nexus.exe/start】启动nexus服务【nexus.exe/stop】停止nexus服务【nexus.exe/run】启动服务 Apache ArchivaJFrog Artifactory]]></content>
      <categories>
        <category>利器</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【阅读】鸟哥的Linux私房菜 基础学习篇]]></title>
    <url>%2F%E3%80%90%E9%98%85%E8%AF%BB%E3%80%91%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AF%87%2F</url>
    <content type="text"><![CDATA[小序Linux内核由Linux Torvalds在1991年开发。硬件 –&gt; 内核 –&gt; 系统调用 –&gt; 应用程序（加粗部分为操作系统）内核： 系统内存管理 软件程序管理 硬件设备管理 文件系统管理]]></content>
      <categories>
        <category>阅读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[android-命令行工具]]></title>
    <url>%2Fandroid-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[https://developer.android.google.cn/studio/command-line aapt2adbAndroid Debug Bridge（ADB），用于通过电脑端与设备交互。ADB是一个C/S架构的命令行工具，端口5037，如下图所示：adb client：运行在PC端；所有的client都是通过5037端口与adb server进行通信的。adb server：作为一个后台的程序运行在PC端的，负责管理client进程以及adb daemon之间的通信。当一个server开启的时候，会自动绑定并且监听5037端口，接收client通过该端口发送过来的命令。同时server扫描设备端口，进行对已连接设备的定位。adb daemon：每个设备/模拟器连接到PC端时，总会开启这么一个后台进程，并且为其分配了两个连续的端口。端口范围5554-5585，adb连接手机的最大数量是16。偶数端口用于server与设备进行交互的，可以让server直接从设备中读取数据，而奇数端口是用来与设备的adb进行连接通信的。 adb命令adb shell命令logcat]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象六大原则]]></title>
    <url>%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[小序系统开发过程中，最难的不是完成系统的开发工作，而是在于后续的升级、维护过程中让系统能够拥抱变化。拥抱变化也就意味着在满足需求且不破坏系统稳定性的前提下保持高可扩展性、高内聚、低耦合，经历各版本的变更之后依然保持清晰、灵活、稳定的系统架构。当然，这是比较理想的情况，但我们必须朝着这个方向去努力，那么遵循面向对象六大原则就是我们走向灵活软件之路所迈出的第一步。 软件的可维护性和可复用性。 好的系统设计应该具备如下三个性质： 可扩展性（Extensibility） 灵活性（Flexibility） 可插入性（Pluggability） 可维护性较低的系统设计，通常有如下几个原因： 复用率低（Immobility） 黏度过高（Viscosity） 脆弱 僵硬 常用的面向对象设计原则包括7个，这些原则并不是孤立存在的，它们相互依赖，相互补充。 开闭原则（OCP）Open Close Principle，缩写OCP。开闭原则由Bertrand Meyer（勃兰特·梅耶）于1988年出版的《面向对象软件构造》一书中提出。抽象化是开闭原则的关键。 定义：软件中的对象（类、模块、函数等）应该对于扩展是开放的，对于修改是封闭的。 软件开发过程中，最不会变化的就是变化本事。 依赖倒置原则（DIP）Dependence Inversion Principle，缩写DIP。 定义：依赖倒置原则指代了一种特定的解耦形式，使得高层次的模块不依赖于低层次模块的实现细节的目的，依赖模块被颠倒了。 高层模块不应该依赖低层模块，两者都应该依赖其抽象 抽象不应该依赖细节 细节应该依赖抽象 java语言中，抽象就是指接口或抽象类，两者都不可以直接被实例化；细节就是实现类。高层模块就是调用端，低层模块就是具体实现类。 里氏替换原则（LSP）Liskov Substitution Principle，缩写LSP。 定义：所有引用基类的地方必须能透明地使用其子类的对象。 单一职责原则（SRP）Single Responsibility Principle，缩写SRP。 定义：就一个类而言，应该仅有一个引起它变化的原因。 接口隔离原则（ISP）InterfaceSegregation Principles，缩写ISP。 定义：客户端不应该依赖它不需要的接口。 迪米特原则（LOD）Law of Demeter，缩写LOD，也称为最少知识原则。 定义：一个对象应该对其他对象有最少的了解。 Only talk to your immedate friends。只与直接的朋友通信。？？？每个对象都必然会与其他对象有耦合关系，两个对象之间的耦合就称为朋友关系，如依赖、关联、组合、聚合等。 类应该对自己需要耦合或调用的类知道得最少，类的内部如何实现与调用者或依赖者没有关系，调用者或者依赖者只需要知道它需要的方法即可，其他的可一概不用管。类与类之间关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。软件总的原则：低耦合、高内聚。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>面向对象六大原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【阅读】深入理解Java虚拟机]]></title>
    <url>%2F%E3%80%90%E9%98%85%E8%AF%BB%E3%80%91%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%2F</url>
    <content type="text"></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http-https]]></title>
    <url>%2F%E3%80%90%E7%BB%BC%E5%90%88%E3%80%91http-https%2F</url>
    <content type="text"></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[持续集成CI]]></title>
    <url>%2F%E3%80%90%E5%88%A9%E5%99%A8%E3%80%91%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90CI%2F</url>
    <content type="text"><![CDATA[引言持续集成是一种软件开发实践，团队内开发成员经常集成工作，。每次集成通过自动化的构建（编译、自动化测试）来验证，从而尽早发现集成错误。Martin Fowler文章：https://martinfowler.com/articles/continuousIntegration.html Jenkins简介Jenkins最初由Sun Microsystems公司在2005年作为Hudson发布的。多年来，已经成长为Java社区最流行的CI系统。Jenkins的强大之处在于它的插件系统。如果构建系统中有新的功能需求，可以创建一个新的插件来扩展Jenkins的能力。 设置 Manage Jenkins | Configure System，Global properties添加如下环境变量：ANDROID_HOME和JAVA_HOME Manage Jenkins | Manage Plugins，安装Gradle插件。 配置VCS仓库，以便Jenkins知道从哪里获取项目源码。 Invoke Gradle script PluginsSonarQubeSonarQube Scanner for Jenkins TeamCityTravis CI如果项目仓库是在GitHub上托管的，则可以使用Travis CI来自动构建。]]></content>
      <categories>
        <category>利器</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-知识框架]]></title>
    <url>%2Fandroid-%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Activityhttps://developer.android.google.cn/guide/components/activities/intro-activities 生命周期管理Activity生命周期 任务和返回栈Fragment引言Android 3.0（API级别11）中引入了Fragment，主要是为了给大屏幕（如平板电脑）上更加动态和灵活的 UI 设计提供支持。由于平板电脑的屏幕比手机屏幕大得多，因此可用于组合和交换 UI 组件的空间更大。利用片段实现此类设计时，您无需管理对视图层次结构的复杂更改。 Fragment表示Activity中的行为或用户界面部分。Fragment必须始终嵌入在Activity中，其生命周期直接受宿主Activity生命周期的影响。 可以将多个Fragment组合在一个Activity中来构建多窗格UI，以及在多个Activity中重复使用某个片段。 可以将Fragment视为Activity的模块化组成部分，它具有自己的生命周期，能接收自己的输入事件 可以在Activity运行时添加或移除Fragment 优势： 模块化（Modularity）：不必把所有代码全部写在Activity中，而是把代码写在各自的Fragment中。 可重用（Reusability）：多个Activity可以重用一个Fragment。 可适配（Adaptability）：根据硬件的屏幕尺寸、屏幕方向，能够方便地实现不同的布局，这样用户体验更好。 生命周期lifecycle onAttach()：Fragment与Activity关联时调用。 onCreate()：创建Fragment时调用。 onCreateView()：首次绘制其用户界面时调用。 onActivityCreated()：在Activity的onCreate()方法已返回时调用。 Activity生命周期对Fragment生命周期影响如下： FragmentManagerFragmentManager findFragmentById() findFragmentByTag() popBackStack()：将Fragment从返回栈中弹出。 addOnBackStackChangedListener()：返回栈变化监听。 FragmentTransactionFragmentTransaction根据用户行为执行添加add()、移除remove()、替换replace()以及其他操作的事务。12345678// Activity中获取FragmentTransaction实例FragmentManager fragmentManager = getFragmentManager();FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();// add()ExampleFragment fragment = new ExampleFragment();fragmentTransaction.add(R.id.fragment_container, fragment);fragmentTransaction.commit(); 以下示例说明了如何将一个片段替换成另一个片段，以及如何在返回栈中保留先前状态：1234567891011// Create new fragment and transactionFragment newFragment = new ExampleFragment();FragmentTransaction transaction = getFragmentManager().beginTransaction();// Replace whatever is in the fragment_container view with this fragment,// and add the transaction to the back stacktransaction.replace(R.id.fragment_container, newFragment);transaction.addToBackStack(null);// Commit the transactiontransaction.commit(); 提示：对于每个片段事务，您都可以通过在提交前调用 setTransition() 来应用过渡动画。调用commit()不会立即执行事务，而是在Activity的UI线程可以执行该操作时再安排其在线程上运行。不过，如有必要，您也可以从UI 线程调用executePendingTransactions()以立即执行commit()提交的事务。通常不必这样做，除非其他线程中的作业依赖该事务。注意：您只能在Activity保存其状态（用户离开 Activity）之前使用commit()提交事务。如果您试图在该时间点后提交，则会引发异常。 这是因为如需恢复Activity，则提交后的状态可能会丢失。 对于丢失提交无关紧要的情况，请使用 commitAllowingStateLoss()。 与Activity通信 Fragment可以通过getActivity()访问Activity实例。 Activity可以通过FragmentManager对象调用findFragmentById()或findFragmentByTag()获取对Fragment的引用 ServiceBroadcast ReceiverContent ProviderAnimator 逐帧动画：Drawable Animation。res/anim，android：oneshot是否循环播放 补间动画：Tween Animation 属性动画（Android 3.0） android.transition（Android 4.4）：本质属性动画。 Tween AnimationAlpha-Scale-Translate-RotateInterpolator（插值器） Property Animation Evaluator：控制属性动画如何计算属性值的。 AnimatorSet ValueAnimator ObjectAnimator：ValueAnimator子类。 android.transition应用资源https://developer.android.google.cn/guide/topics/resources/providing-resources 应用清单文件https://developer.android.google.cn/guide/topics/manifest/manifest-intro 应用权限https://developer.android.google.cn/guide/topics/permissions/overview 设备兼容性https://developer.android.google.cn/guide/practices/compatibility NDK(Native Develop Kit)https://developer.android.google.cn/ndk原生开发工具包（NDK）是一套工具，允许您为 Android 使用C和C++代码，并提供众多平台库，您可用其管理原生Activity和访问物理设备组件，例如传感器和触摸输入。借助Android Studio 2.2或更高版本，使用NDK将C和C++代码编译到原生库中，然后使用IDE集成构建系统 Gradle将您的库封装入APK。然后，Java代码可以通过Java原生接口 (JNI) 框架，调用您原生库中的函数。Android Studio用于编译原生库的默认构建工具是CMake。由于很多现有项目都使用构建工具包，因此Android Studio也支持ndk-build。不过，如果您要创建新的原生库，则应使用 CMake。 使用场景 在平台之间移植其应用。 进一步提升设备性能，以实现低延迟时间，或运行计算密集型应用，如游戏或物理模拟。 重复使用自己或其他开发者的C或C++库。 编译和调试原生代码组件Android 原生开发工具包 (NDK)：这套工具允许您为 Android 使用 C 和 C++ 代码。CMake：一款外部构建工具，可与 Gradle 搭配使用来构建原生库。如果您只计划使用 ndk-build，则不需要此组件。LLDB：一种调试程序，Android Studio 使用它来调试原生代码。安装：Tools &gt; SDK Manager 创建或导入原生项目工作原理CPU和架构使用原生代码时，硬件很重要。NDK提供各种ABI供您选择，可让您确保针对正确的架构和CPU进行编译。 ABI不同的Android手机使用不同的CPU，进而支持不同的指令集。CPU与指令集的每种组合都有专属的应用二进制界面，即ABI。ABI可以非常精确地定义应用的机器代码在运行时如何与系统交互。您必须为应用要使用的每个CPU架构指定ABI。 参考https://developer.android.google.cn/guidehttps://developer.android.google.cn/reference/packages]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-构建流程]]></title>
    <url>%2Fandroid-%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[构建流程典型Android应用模块的构建流程通常遵循下列步骤： 编译器将源代码转换成DEX（Dalvik Executable）文件，将所有其他内容转换成已编译资源。 APK打包器将DEX文件和已编译资源合并成单个APK。 APK打包器使用调试或发布密钥库签署您的APK 生成最终APK之前，打包器会使用zipalign工具对应用进行优化，减少其在设备上运行时占用的内存。 应用签名https://developer.android.google.cn/studio/build/configure-apk-splits.html 参考https://developer.android.google.cn/studio/build]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-系统架构]]></title>
    <url>%2Fandroid-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[平台架构Android是一种基于Linux的自由及开放源代码的操作系统，主要使用在智能手机、平板电脑等设备上。下图所示为Android平台的主要组件。 Linux kernelAndroid平台的基础是Linux内核。使用Linux内核可让Android利用主要安全功能，并且允许设备制造商为著名的内核开发硬件驱动程序。在操作系统级别，Android平台不仅提供Linux内核的安全功能，而且还提供安全的进程间通信（IPC）机制，以便在不同进程中运行的应用之间安全通信。操作系统级别的这些安全功能旨在确保即使是原生代码也要受应用沙盒的限制。Linux内核为Android提供了一些关键的安全功能，包括： 基于用户的权限模式 进程隔离 用于实现安全IPC的可扩展机制 能够移除内核中不必要的和可能不安全的部分 Android的应用安全性是由应用沙盒强制实施的。 HAL硬件抽象层（HAL）提供标准界面，向更高级别的Java API框架显示设备硬件功能。HAL包含多个库模块，其中每个模块都为特定类型的硬件组件实现一个界面，例如相机或蓝牙模块。当Java API框架要求访问设备硬件时，Android系统将为该硬件组件加载库模块。 相机 蓝牙Android 8.0 架构蓝牙应用通过Binder与蓝牙进程进行通信。蓝牙进程使用JNI与蓝牙堆栈通信，并向开发者提供对各种蓝牙配置文件的访问权限。android.bluetooth 原生C/C++库许多核心Android系统组件和服务（例如ART和HAL）构建自原生代码，需要以C和C++编写的原生库。Android 平台提供Java框架API以向应用显示其中部分原生库的功能。例如，您可以通过Android框架的Java OpenGL API访问OpenGL ES，以支持在应用中绘制和操作2D和3D图形。如果开发的是需要C或C++代码的应用，可以使用Android NDK直接从原生代码访问某些原生平台库。 Android RuntimeAndroid 5.0（API 21）或更高版本，每个应用都在其自己的进程中运行，并且有其自己的Android Runtime（ART）实例。ART编写为通过执行DEX文件在低内存设备上运行多个虚拟机，DEX文件是一种专为Android设计的字节码格式，经过优化，使用的内存很少。编译工具链（例如Jack已被弃用）将Java源代码编译为DEX字节码，使其可在Android平台上运行。ART的部分主要功能包括： 预先 (AOT) 和即时 (JIT) 编译 优化的垃圾回收 (GC) 更好的调试支持，包括专用采样分析器、详细的诊断异常和崩溃报告，并且能够设置监视点以监控特定字段 Android 5.0（API 21）之前，Dalvik是Android Runtime。如果您的应用在ART上运行效果很好，那么它应该也可在 Dalvik 上运行，但反过来不一定。Android还包含一套核心运行时库，可提供Java API框架使用的Java 编程语言大部分功能，包括一些Java 8语言功能。 Java API框架您可通过以Java语言编写的API使用Android OS的整个功能集。这些API形成创建Android应用所需的构建块，它们可简化核心模块化系统组件和服务的重复使用，包括以下组件和服务： 丰富、可扩展的视图系统，可用以构建应用的 UI，包括列表、网格、文本框、按钮甚至可嵌入的网络浏览器 资源管理器，用于访问非代码资源，例如本地化的字符串、图形和布局文件 通知管理器，可让所有应用在状态栏中显示自定义提醒 Activity管理器，用于管理应用的生命周期，提供常见的导航返回栈 内容提供程序，可让应用访问其他应用（例如“联系人”应用）中的数据或者共享其自己的数据开发者可以完全访问Android系统应用使用的框架API。 应用程序层用户直接可见的应用程序。 参考https://developer.android.google.cn/guide/platform/]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-versions]]></title>
    <url>%2Fandroid-versions%2F</url>
    <content type="text"><![CDATA[简介android-系统架构 android 9.0 - API 282018年8月7日发布，代号Pie。Android 9.0 Pie WIFI RTT进行室内定位Android 9添加了对IEEE 802.11mc Wi-Fi协议（也称为Wi-Fi Round-Trip-Time(RTT)）的平台支持，从而让您的应用可以利用室内定位功能。在运行Android 9且具有硬件支持的设备上，应用可以使用RTT API来测量与附近支持RTT的Wi-Fi接入点(AP)的距离。设备必须已启用位置服务并开启Wi-Fi扫描（在 Settings &gt; Location 下），同时您的应用必须具有ACCESS_FINE_LOCATION权限。 显示屏缺口支持Android 9支持最新的全面屏，其中包含为摄像头和扬声器预留空间的屏幕缺口。通过DisplayCutout类可确定非功能区域的位置和形状，这些区域不应显示内容。要确定这些屏幕缺口区域是否存在及其位置，请使用 getDisplayCutout()) 函数。 通知动画自动填充框架安全增强功能Android备份无障碍功能旋转文本设备端系统跟踪android 8.1 - API 272017年12月5日发布。 android 8.0 - API 262017年8月22日发布，代号Oreo（奥利奥）。Android 8.0 Oreo android 7.1 - API 252016年12月5日发布。 android 7.0 - API 242016年8月22日发布，代号Nougat（牛轧糖）。Android 7.0 Nougat android 6.0 - API 232015年5月28日发布，代号Marshmallow（棉花糖）。Android 6.0 Marshmallow android 5.1 - API 22android 5.0 - API 212014年10月15日发布，代号Lollipop（）Android 5.0 Lollipop扩展了Android的应用范围，从手机、平板电脑和可穿戴式设备，扩展到电视和汽车。 Material Design以性能为中心通知android 4.4W - API 20android 4.4 - API 19Android 4.4 KitKat android 4.3 - API 18android 4.2-4.2.2 - API 17android 4.1-4.1.1 - API 16android 4.0.3–4.0.4 - API 15android 4.0 - API 14android 3.2 - API 13android 3.1 - API 12android 3.0 - API 11android 2.3.3 - API 10android 2.3 - API 9android 2.2 - API 8android 2.1 - API 7android 2.0.1 - API 6android 1.6 - API 4android 1.5 - API 3android 1.1 - API 2android 1.0 - API 12008年，在Google I/O大会上，谷歌提出了Android HAL架构图。2008年9月，正式发布了Android 1.0系统。 文章参考https://developer.android.google.cn/about/versions/pie/]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>sw version</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-知识框架]]></title>
    <url>%2Fjava-%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[一次编译，到处运行。 简介Class是对象的抽象；对象则是Class的实例。 java程序运行机制java源文件 –javac编译–&gt; *.class字节码文件（与平台无关，面向JVM） –java解释执行–&gt; 特定平台的机器码（先编译、后解释）计算机高级语言按程序执行方式分为编译型和解释型两种。 编译型语言指使用专门的编译器，针对特定平台将某种高级语言源代码一次性“翻译”成该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式，这个转换过程称为编译。（C、C++、Objective-C、Pascal） 解释型语言指使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行的语言。效率低，跨平台。（Ruby、Python） JVM负责解释执行字节码文件的Java虚拟机。JVM就是转换器，分为向上和向下两个部分。 java程序结构数据类型java是一种强类型语言。意味着必须为每一个变量声明一种类型。基本数据类型8种：java中整型的范围与运行java代码的机器无关。注意：Java没有任何无符号类型。注释：JDk 5.0中，可以使用十六进制表示浮点数值。如，0.125表示为0x1.0p-3。十六进制表示法中，使用p表示指数，而不是e。注意，尾数采用十六进制，指数采用十进制。指数的基数是2，不是10。所有的浮点数值计算都遵循IEEE 754规范。警告：浮点数值不适用于禁止出现舍入误差的金融计算中。如果需要在数值计算中不含有任何舍入误差，就应该使用BigDecimal类。 运算符位运算&amp;与&amp;&amp;区别：&amp;&amp;具有短路功能。~：按位非^：按位异或 移位运算&gt;&gt;：右移运算符，右移n位相当于除以2的n次方&lt;&lt;：左移运算符，左移n位相当于乘以2的n次方&gt;&gt;&gt;：无符号右移例：2乘以8最有效率的方法是，2&lt;&lt;3；因为位运算是CPU直接支持的，效率最高。 流程控制 分支结构：if和switch 循环结构：while、do while、for、foreach（JDK 5支持） foreach:for (type variableName : array | collection) {// variableName 自动迭代访问每个元素…}switch支持byte、short、char、int、枚举类型、String（Java 7支持）do {//至少执行一次} while();break不仅结束其所在的循环，还可以直接结束其外层循环。跳出多重循环时，可以使外层的循环条件表达式的结果受到里层循环体代码的控制。 数组数组的初始化完成，在内存中所占的空间将被固定下来，因此数组长度不可改变。 静态初始化：arrayName = new type[]{element1,element2…} 动态初始化：arrayName = new type[length] 数组是一种引用数据类型，数组引用变量只是一个引用，数组元素和数组变量在内存里是分开存放的。实际的数组对象存储在堆（Heap）内存中；如果引用该数组对象的数组引用变量是局部变量，存储在栈（Stack）内存中。 每个方法执行时，建立自己的内存栈，方法内部定义的变量将会逐个放入这块栈内存里，方法结束，内存栈自然销毁；在程序中创建一个对象时，这个对象被保存到运行时数据区，方便反复利用，这个运行时数据区就是堆内存。 面向对象引言封装、继承、多态；抽象也是重要部分；类是对象的抽象；对象则是类的实例。类不是一种具体存在，实例才是具体存在。“基于对象”（JavaScript）没有继承的特点；Java不允许直接访问对象，而是通过对对象的引用来操作对象。public、protected、private、static、final、abstract 类、对象、变量、方法类是某一批对象的抽象；对象是一个具体存在的实体。方法名通常建议以英文动词开头。引用变量（指针）里存放的仅仅是一个引用（地址值），它指向实际的对象。堆内存里的对象可以有多个引用，即多个引用变量指向同一个对象。this总是指向调用该方法的对象。最大的作用就是让类中一个方法，访问该类里的另一个方法或实例变量。java里方法的参数传递方式只有一种：值传递。（副本）java把内存划分为两种：栈内存和堆内存。栈内存当超过变量的作用域后，Java会自动释放为该变量分配的内存空间；堆内存用来存放由new创建的对象和数组，在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。JDK 1.5后，Java允许定义形参个数可变的参数。只能处于最后一个形参，类型后（…），多个参数值被当成数组传入。类：类加载、类验证、类准备、类解析、类初始化。 三大特性封装继承overload（重载）与override（方法覆盖）super当程序创建一个子类对象时，系统不仅会为该类中定义的实例变量分配内存，也会为它从父类继承得到的所有实例变量分配内存。 多态Java引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。如果编译时类型和运行时类型不一致，就出现多态。 关键字abstract抽象方法和抽象类： 抽象类里可以没有抽象方法。抽象方法不能有方法体。 抽象类不能被实例化。抽象类的构造器不能用于创建实例，主要用于被其子类调用。 final和abstract永远不能同时使用。（abstract修饰类只能被继承，修饰方法必须由子类重写；fina修饰类不能被继承，修饰方法不能被重写） abstract不能用于修饰成员变量和局部变量；不能修饰构造器。 static和abstract不能同时修饰某个方法，但可以同时修饰内部类。abstract修饰方法不能定义为private访问权限。 抽象类体现的是一种模板模式的设计。 final final修饰的成员变量必须由程序员显式地指定初始值。可以指定默认值，也可以在构造器或初始化块中分配初始值（之前不能访问该值）。 final修饰的形参不能赋值 final修饰引用类型变量，引用地址不变，但对象内容可以发生改变。 final修饰的方法不可被重写，Object类getClass()；可以被重载。 final修饰的类不可以有子类 static static修饰的成员不能访问没有static修饰的成员。 static修饰的成员表明它属于这个类本身，而不属于该类的单个实例。 volatile接口内部类内部类主要用于设计具有相互协作关系的类集合。 匿名内部类匿名内部类适合创建只需要一次使用的类。 匿名内部类不能是抽象类。 匿名内部类不能定义构造器。匿名内部类没有类名。 枚举Java从JDK1.5开始支持枚举。添加了抽象类java.lang.Enum，在枚举中可以定义属性、构造方法、普通方法、抽象方法。一个Java源文件最多只能定义一个public访问权限的枚举类，且该Java源文件必须和该枚举类的类名相同。可以像使用普通的类一样使用枚举，编译器做了些什么？欲知详情，最有效的途径就是查看生成的字节码。 泛型编写可以应用于各种类型的代码。多态——接口——Java SE5（泛型，实现了参数化类型的概念）类型参数，用尖括号括住，放在类名后面。然后在使用这个类的时候，再用实际的类型替换此类型参数。元组（&lt;A,B,C…&gt;） 集合Java集合类库也将接口和实现分离。队列有两种实现方式：循环数组和链表。Java SE 5.0开始集合是带有类型参数的泛型类。Java类库中集合类的基本接口是Collection接口。 List有序，可重复。 ArrayListVector如果涉及到多线程，用Vector（同步）。ArrayList与Vector的区别： 同步性：ArrayList是线程不安全的；Vector是线程安全的，也就是说方法之间是线程同步的。 数据增长：ArrayList和Vector都可以设置初始的空间大小，Vector还可以设置增长的空间大小；ArrayList没有提供方法设置。Vector默认增长为原来的2倍；ArrayList（源代码查看增长为1.5倍） LinkedList使用双向链表实现存储。 Set无序，不可重复。 HashSet底层由HashMap实现。以哈希表的形式存放元素，插入删除速度很快。 LinkedHashSetMapHashMapTreeMapHashtable继承于DictionaryHashMap与Hashtable的区别： 同步性：HashMap是线程不安全的；Hashtable是线程安全的。 值：HashMap可以将null作为key或value Collections反射https://www.cnblogs.com/whgk/p/6122036.htmlJava中获得Class对象通常三种方式： Class.forName(String className) 调用某个类的class属性来获取该类对应的Class对象。 调用某个对象的getClass()方法。 1和2都是直接根据类来取得该类的Class对象，相比之下，第二种优势： 代码更安全。编译阶段可以检查需要访问的Class对象是否存在。 程序性能更好。因无需调用方法。 异常处理异常机制已成为判断一门编程语言是否成熟的标准，除了C语言没有提供异常机制之外。Java异常分为两种：Checked异常和Runtime异常。Throwable====&gt;Exception and ErrorIndexOutOfBoundsExceptionNumberFormatExceptionArithmeticExceptionNullPointerException throwsthrows：用于声明该方法可能抛出的异常。 throwthrow：抛出实际的异常。 try catch finallyJava7开始一个catch块可以捕获多种类型的异常。|隔开；捕获多种类型的异常时，异常变量有隐式的final修饰；异常对象常用方法：getMessage()：返回异常的详细描述字符串；printStackTrace()：将该异常的跟踪栈信息输出到标准错误输出；printStackTrace(PrintStream s)：将该异常的跟踪栈信息输出到指定输出流；getStackTrace()：返回该异常的跟踪栈信息；System.exit(1)语句退出虚拟机，finally将失去执行的机会。 IO引言输入、输出流分为字节流和字符流。Java的IO流使用一种装饰器设计模式，将IO流分为底层节点流和上层处理流。Java 7在java.nio新的IO API，称为NIO 2。Java对象的序列化机制，使用序列化机制可以把内存中的Java对象转换成二进制字节流，就可以把Java对象存储到磁盘里，或者在网络上传输Java对象。这是Java提供分布式编程的重要基础。 FileIO流序列化对象序列化（Serializable）：将一个对象编码成一个字节流。代价：一旦一个类被发布，就大大降低了“改变这个类的实现”的灵活性；增加了出现bug和安全漏洞的可能性；随着类发行新的版本，相关的测试负担也增加了。 注解引言每当创建描述符性质的类或接口时，一旦其中包含了重复性的工作，那就可以考虑使用注解来简化与自动化该过程。Android中有两种应用方式，一种方式是基于反射的，即在程序的运行期间获取类信息进行反射调用；另一种是使用注解处理，在编译期间生成许多代码，然后在运行期间通过调用这些代码来实现目标功能。Java中注解分为标准注解和元注解。标准注解是Java为我们提供的预定义的注解，共有四种：@Override、@Deprecated、@SuppressWarnnings和@SafeVarags。元注解是用来提供给用户自定义注解用的，共有五种（截止Java8） @Target定义注解将应用于什么地方（如是一个方法或一个域）ElementType @Retention定义该注解在哪一个级别可用。RetentionPolicy枚举： SOURCE：注解将被编译器丢弃 CLASS：注解在class文件中使用，但会被JVM丢弃 RUNTIME：在运行期保留注解，可以通过反射读取注解的信息 垃圾回收机制内存泄漏：分配的内存得不到及时回收。Java程序的内存分配和回收都是由JRE在后台自动进行的。（垃圾回收GC）JRE会提供一个后台线程来进行检测和控制。JVM会把程序创建的对象存放在堆空间中。运行时的数据存储区有堆（Heap）和堆栈（Stack）。 软、弱和虚引用java.lang.refSoftReference、PhantomReference、WeakReference 强引用 软引用：有可能被垃圾回收机制回收。 弱引用：不管内存是否足够，总会回收该对象所占用的内存。 虚引用：完全类似于没有引用。主要用于跟踪对象被垃圾回收的状态，不能单独使用，必须和引用队列联合使用。 其他JNIJNI（Java Native Interface） JARJava Archive FileJAR]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML类图]]></title>
    <url>%2F%E3%80%90%E7%BB%BC%E5%90%88%E3%80%91UML%E7%B1%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[Unified Model Language（UML），统一建模语言。类图用于描述系统中所包含的类以及它们之间的相互关系，帮助人们简化对系统的理解，它是系统分析和设计阶段的重要产物，也是系统编码和测试的重要模型依据。]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>UML类图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[URI-URL-URN]]></title>
    <url>%2F%E3%80%90%E7%BB%BC%E5%90%88%E3%80%91URI-URL-URN%2F</url>
    <content type="text"><![CDATA[URI（Uniform Resource Identifier，统一资源标识符）URL（Uniform Resource Locator，统一资源定位符）URN（Uniform Resource Name，统一资源名称）scheme://host/path]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>URI</tag>
        <tag>URL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-versions]]></title>
    <url>%2Fjava-versions%2F</url>
    <content type="text"><![CDATA[简介JDK（Java SE Development Kit），Java标准版开发包。JRE（Java Runtime Environment），Java运行时环境。运行Java程序所必须环境的集合，包含JVM标准实现及Java核心类库。 JDK目录 bin：该路径存放了JDK的各种工具命令，javac、java等。 db：该路径安装Java DB的路径。 include：一些平台特定的头文件。 jre：运行Java程序所必需的JRE环境。 lib：存放JDK工具命令的实际执行程序 Java SE 112018年9月25日，Oracle正式发布Java 11（LTS长期支持2026年9月），Java 8以后的首个长期版本。下载 新特性Java SE 102018年3月20日，Java 10发布。 Java SE 92017年9月，Java 9发布。 Java SE 82014/3/18，Oracle发布Java SE 8。 新特性 Lambda表达式 Java SE 72011/7/28，Oracle发布Java SE 7，代号Dolphin（海豚） 新特性 引入二进制整数 支持字符串的switch语句 菱形语法 多异常捕捉 自动关闭资源的try语句 2009/4/20，Oracle收购SunJDK 1.62006/12（Java SE 6） JDK 1.52004/10（改名为Java SE 5.0、Java EE和Java ME）泛型、增强的for语句、可变数量的形参、注释、自动拆箱和装箱等 JDK 1.21998/12Java分成J2EE、J2SE、J2ME三个版本J2ME：主要用于控制移动设备和信息家电等有限存储的设备。J2SE：整个Java技术的核心和基础。J2EE：提供企业应用开发相关的完整解决方案。 JDK 1.01996]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>sw version</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDE-Android Studio]]></title>
    <url>%2F%E3%80%90%E5%88%A9%E5%99%A8%E3%80%91IDE-AndroidStudio%2F</url>
    <content type="text"><![CDATA[工欲善其事，必先利其器。——《论语·卫灵公》 配置Logcat颜色 Assert：#8F0005 深红Debug：#0070BB 蓝Error：#FF0006 红Info：#48BB31 绿Verbose：#BBBBBB 白Warning：#BBBB23 黄 断点调试与管理 1 Show Execution Point2 Step Over：单步执行。如果当前行为方法调用（不会跳到方法内部），方法执行完后跳到下一行。3 Step Into：与Step Over不同的是，会跳到方法内部（非类库的方法）。4 Force Step Into：与Step Into不同的是，始终跳到方法内部。5 Step Out：跳出方法，返回到该方法调用处。6 Drop Frame7 Run to Cursor8 Resume Program：程序执行到下一个断点处。9 Stop：停止调试。 变量观察 选中变量，右键选择Add to Watches 修改变量值，调试结果。选择Set Value 条件断点循环体内设置。 日志断点Suspend取消选中，显示日志输入框。 异常断点单击如下图标，在弹窗中新建异常断点。 变量断点 方法断点在方法名所在行添加断点。 Plugins]]></content>
      <categories>
        <category>利器</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F%E3%80%90%E5%88%A9%E5%99%A8%E3%80%91Markdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[简介Markdown是一种轻量级的标记语言，将作者从繁杂的排版工作中解放出来，实现易读易写的文章写作。 Windows平台编辑器 MarkdownPad一款全功能的编辑器。 标题 #：H1 ##：H2 ###：H3 文本 加粗：文本左右分别添加两个* 斜体：文本左右分别添加一个* 加粗斜体：文本左右分别添加三个* 删除线：文本左右分别添加两个~ 文本颜色： 1&lt;font color="#ff0000"&gt;颜色文本&lt;/font&gt; 文本增加背景色：文本左右分别添加一个反引号 ` 引用在引用的文本前面添加&gt;，且可以嵌套，&gt;&gt;或&gt;&gt;&gt; 图片 Markdown显示图片语法： 1![图片说明](https://i.imgur.com/4u0hKYA.jpg) 效果如下图： 固定图片显示大小： 1&lt;img src="https://i.imgur.com/4u0hKYA.jpg" width=200 height=200 /&gt; 效果如下图： 图片按比例显示： 1&lt;img src="https://i.imgur.com/4u0hKYA.jpg" width=25% height=25% /&gt; 效果如下图： 链接Markdown显示连接语法：1[链接显示文本]（https://www.baidu.com） 列表 无序列表 有序列表：数字 + . + 空格 第一点 第二点 分隔线一行连续使用三个或以上的-或* 代码 每一行前面加一个tab或4个空格可以标记一个代码片段，效果如下图：public int main() { reutrn 0; } 连续三个反引号`（需要代码高亮的话，加上代码类型），键盘上数字1前面按键，如下图：效果如下图：12345public class main &#123; public static void main(String[] args)&#123; System.out.println("hello java"); &#125; &#125; 表格123|标题1|标题2|标题3||:---|:---:|---:||第一行第一列|01|第一行第三列| 注意：表格语句上一行必须为空行，否则表格无效。效果如下图： 标题1 标题2 标题3 第一行第一列 01 第一行第三列 说明： :-表示居左对齐；:-:表示居中对齐；-:表示居右对齐 -至少有一个 流程图]]></content>
      <categories>
        <category>利器</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-NexT主题配置]]></title>
    <url>%2F%E3%80%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E3%80%91Hexo-NexT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[小序博客搭建，可以参考博文 搭建个人博客-GitHub-PagesHexo的配置文件_config.yml分两种：站点配置文件、主题配置文件。站点配置文件参考Hexo，主题配置文件参考NexT本文主要讲解主题配置文件_config.yml（文件路径：hexo目录\themes\next\_config.yml）GitHub hexo-theme-next Site Information Settings设置站点信息favicon:修改网站图标，图片保存在目录\themes\next\source\images中。footer:站点底部 since:2018站点创建时间creative_commons:文章底部添加版权信息 Menu Settings 菜单项（名称和链接） 菜单项的显示文本 菜单项对应的图标。NexT使用的是Font Awesome提供的图标，Font Awesome提供了600+的图标，可以满足绝大多数的场景。 注意：菜单点击可能报Cannot GET **，创建page就可以了，命令如下：12// name为categories、tags、about等，文件存储路径为：root\sourcehexo new page &apos;name&apos; 在source目录下会生成菜单对应文件夹，修改文件夹中的index.md文件，新增type属性，如下：12345---title: 分类date: 2018-12-16 17:03:04type: &quot;categories&quot;--- Scheme SettingsScheme是NexT提供的一种特性，可以设置不同的外观。同时，几乎所有的配置都可以在Scheme之间共用。目前NexT支持以下几种Scheme: Muse-默认Scheme，NexT最初的版本，黑白色调，大量留白 Mist-Muse的紧凑版本，整洁有序的单栏外观 Pisces-双栏Scheme，小家碧玉似的清新 Gemini-左侧网站信息及目录，块+片段结构布局 Sidebar Settings设置侧栏 sidebar:侧栏的位置 sidebar:侧栏显示的时机 avatar:头像 social:社交链接 github_banner:（网站右上角显示关注GitHub图标） Blog rolls友情链接 toc:文章目录 Post Settings reward:打赏 wechat_subscriber:微信订阅 Third Party Services Settingslocal_search:网站添加搜索needmoreshare2:内容分享 在博客根目录执行如下命令： 1git clone https://github.com/theme-next/theme-next-needmoreshare2 themes/next/source/lib/needsharebutton 主题配置文件中，搜索needmoreshare2: 评论系统 畅言 官网 12345# changyanchangyan: enable: false appid: appkey: Valine 官网 DaoVoice修改文章内链接样式在文件\themes\next\source\css_common\components\post\post.styl末尾，添加如下代码：1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; //原始链接颜色 border-bottom: none; border-bottom: 1px solid #0593d3; //底部分割线颜色 &amp;:hover &#123; color: #fc6423; //鼠标经过颜色 border-bottom: none; border-bottom: 1px solid #fc6423; //底部分割线颜色 &#125;&#125; 修改文章底部带#的标签实现效果图： \themes\next\layout_macro\post.swig中找到rel=”tag”&gt;#，将#替换为1&lt;i class="fa fa-tag"&gt;&lt;/i&gt; 文章末尾添加结束标语实现效果图： \themes\next\layout_macro中新建passage-end-tag.swig文件，添加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;-------------本文结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 打开\themes\next\layout_macro\post.swig文件，在post-body后，post-footer前，添加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 修改主题配置文件_config.yml，末尾添加如下内容： 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 网站底部添加总访客量、总访问量方法一： 打开\themes\next\layout_partials\footer.swig文件，在copyright之前添加如下代码：1&lt;script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 单个用户连续点击n篇文章，记录n次访问量。123&lt;span id="busuanzi_container_site_pv"&gt; 总访问量&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;次&lt;/span&gt; 单个用户连续点击n篇文章，只记录1次访客数。123&lt;span id="busuanzi_container_site_uv"&gt; 总访客数&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;人次&lt;/span&gt; 方法二：主题配置文件_config.yml，搜索busuanzi_count:注：本地预览时，数字存在异常，部署云端即可恢复正常。 网站底部添加字数统计npm install hexo-wordcount –save打开文件\themes\next\layout_partials\footer.swig，末尾加上如下代码：1234&lt;div class="theme-info"&gt; &lt;div class="powered-by"&gt;&lt;/div&gt; &lt;span class="post-count"&gt;全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 点击出现爱心效果 在目录\themes\next\source\js\src中新建文件love.js，添加如下代码： 1!function (e, t, a) &#123; function n() &#123; c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"), o(), r() &#125; function r() &#123; for (var e = 0; e &lt; d.length; e++)d[e].alpha &lt;= 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y-- , d[e].scale += .004, d[e].alpha -= .013, d[e].el.style.cssText = "left:" + d[e].x + "px;top:" + d[e].y + "px;opacity:" + d[e].alpha + ";transform:scale(" + d[e].scale + "," + d[e].scale + ") rotate(45deg);background:" + d[e].color + ";z-index:99999"); requestAnimationFrame(r) &#125; function o() &#123; var t = "function" == typeof e.onclick &amp;&amp; e.onclick; e.onclick = function (e) &#123; t &amp;&amp; t(), i(e) &#125; &#125; function i(e) &#123; var a = t.createElement("div"); a.className = "heart", d.push(&#123; el: a, x: e.clientX - 5, y: e.clientY - 5, scale: 1, alpha: 1, color: s() &#125;), t.body.appendChild(a) &#125; function c(e) &#123; var a = t.createElement("style"); a.type = "text/css"; try &#123; a.appendChild(t.createTextNode(e)) &#125; catch (t) &#123; a.styleSheet.cssText = e &#125; t.getElementsByTagName("head")[0].appendChild(a) &#125; function s() &#123; return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")" &#125; var d = []; e.requestAnimationFrame = function () &#123; return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) &#123; setTimeout(e, 1e3 / 60) &#125; &#125;(), n() &#125;(window, document); 打开文件\themes\next\layout_layout.swig，末尾加上如下代码： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 添加网易云音乐\themes\next\layout_macro\sidebar.swig 添加依赖在目录\themes\next下，开启Git Bash，执行命令。 设置动态背景canvas_nest:1git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest 站点顶部进度条pace:1git clone https://github.com/theme-next/theme-next-pace source/lib/pace 参考https://theme-next.org/]]></content>
      <categories>
        <category>搭建环境</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客-GitHub-Pages]]></title>
    <url>%2F%E3%80%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E3%80%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-GitHub-Pages%2F</url>
    <content type="text"><![CDATA[小序 创建GitHub Pages 安装Git 安装Node.js 安装hexo GitHub Pages 注册GitHub账号，新建仓库，仓库名格式为（用户名.github.io），用户名必须与GitHub保持一致。 仓库中点击Settings菜单，找到GitHub Pages Choose a theme HexoHexo是一个快速、简洁且高效的博客框架。使用Markdown解析文章，在几秒内，即可利用靓丽的主题生成静态网页。Windows搭建Hexo博客系统并部署到GitHub 安装hexo本地环境，使用命令：npm install -g hexo 计算机本地新建保存博客文件夹 初始化hexo博客工程：hexo init 执行编译与预览命令后，hexo预览http://localhost:4000/ 命令命令[hexo n “博客名称”] 新建博客 themes主题设置 博客根目录：git clone https://github.com/theme-next/hexo-theme-next themes/next 修改站点配置文件_config.yml中theme为目标主题名称 theme-NexT主题配置文件_config.yml scheme:目前NexT支持四种Scheme menu:设置菜单 sidebar:设置侧边栏 avatar:设置头像 favicon:设置网站缩略图 plugins 安装：npm install hexo-xxx –save 卸载：npm remove hexo-xxx –save hexo部署插件 npm install hexo-deployer-git –save 修改站点配置文件_config.yml，在deploy下指定仓库路径和部署的协议 hexo g hexo d hexo-adminnpm install hexo-admin –saveHexo Admin hexo-tocnpm install hexo-toc –save文章中添加目录，在站点配置文件_config.yml中，添加如下信息：12345678910# 文章顶部添加&lt;!-- toc --&gt;，会在标题下方生成文章目录。toc: maxdepth: 3 class: toc slugify: transliteration decodeEntities: false anchor: position: after symbol: &apos;&apos; style: header-anchor 注意坑：主题为NexT时，不要安装该插件，会导致sidebar中文章目录显示错误且不跳转。 jekylljekyll jekyll themes]]></content>
      <categories>
        <category>搭建环境</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
</search>
