<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[android-API-Support-Library]]></title>
    <url>%2Fandroid-API-Support-Library%2F</url>
    <content type="text"></content>
      <categories>
        <category>android</category>
        <category>API</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-API-Platform]]></title>
    <url>%2Fandroid-API-Platform%2F</url>
    <content type="text"></content>
      <categories>
        <category>android</category>
        <category>API</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-view-滑动]]></title>
    <url>%2Fandroid-view-%E6%BB%91%E5%8A%A8%2F</url>
    <content type="text"></content>
      <categories>
        <category>android</category>
        <category>view</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-view-工作原理]]></title>
    <url>%2Fandroid-view-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[UI层级Android UI层级如下图： Activity是Android的四大组件之一，与用户交互的窗口。 Window是抽象类，具体实现类是PhoneWindow。Android中的视图都是附加在Window上的，因此Window实际是View的直接管理者，Window和View通过ViewRootImpl来建立联系。Activity中的方法setContentView也是通过Window来完成的。（接口WindowManager继承ViewManager） Activity对象被创建完毕后，会将DecorView添加到Window中，同时会创建ViewRootImpl对象，并将ViewRootImpl对象和DecorView建立关联。 View绘制流程 Measure（测量）：[View的测量过程] View的measure（final，子类不能重写该方法）方法进行测量，measure方法会调用View的onMeasure方法。源码如下： 123456789101112131415161718192021222324252627282930protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125;/** * Utility to return a default size. Uses the supplied size if the * MeasureSpec imposed no constraints. Will get larger if allowed * by the MeasureSpec. * * @param size Default size for this view * @param measureSpec Constraints imposed by the parent * @return The size this view should be. */public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; [ViewGroup的测量过程] ViewGroup测量完自身后，还会遍历调用所有子View的measure方法。ViewGroup为抽象类，因此没有重写View的onMeasure方法，但是提供了方法measureChildren。源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940/** * Ask all of the children of this view to measure themselves, taking into * account both the MeasureSpec requirements for this view and its padding. * We skip children that are in the GONE state The heavy lifting is done in * getChildMeasureSpec. * * @param widthMeasureSpec The width requirements for this view * @param heightMeasureSpec The height requirements for this view */protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125;&#125;/** * Ask one of the children of this view to measure itself, taking into * account both the MeasureSpec requirements for this view and its padding. * The heavy lifting is done in getChildMeasureSpec. * * @param child The child to measure * @param parentWidthMeasureSpec The width requirements for this view * @param parentHeightMeasureSpec The height requirements for this view */protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; 注意：测量完成后，通过getMeasuredWidth与getMeasuredHeight获取宽高。onMeasure方法中可能不准确，在onLayout方法中获取比较靠谱。Activity中获取View宽高的方式：方法1：view.post(runnable)方法2：Activity中重写方法onWindowFocusChanged。页面焦点改变时，该方法就会被调用。方法3：ViewTreeObserver - onGlobalLayoutListener方法4： Layout（布局）： Draw（绘制）：]]></content>
      <categories>
        <category>android</category>
        <category>view</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-view-事件分发]]></title>
    <url>%2Fandroid-view-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%2F</url>
    <content type="text"><![CDATA[点击事件的分发，其实就是对MotionEvent事件的分发过程，产生MotionEvent后，系统需要把这个事件传递给一个具体的View，而这个传递的过程就是分发过程。 事件传递的三个阶段： 分发（Dispatch）：事件分发对应dispatchTouchEvent方法。方法返回值true表示事件被当前视图消费掉，不再继续分发事件；方法返回值是super.dispatchTouchEvent表示继续分发该事件。如果当前视图是ViewGroup及其子类，则会调用onInterceptTouchEvent方法判定是否拦截该事件。 拦截（Intercept）：事件拦截对应onInterceptTouchEvent方法，这个方法只在ViewGroup及其子类中存在，在View和Activity中是不存在的。返回true，不会继续传递给子View，返回false或父类同名方法，则事件会继续传递给子View。 消费（Consume）：事件的消费对应着onTouchEvent。方法返回值true表示当前视图可以处理对应的事件，事件不会向上传递给父视图；返回值为false表示当前视图不处理这个事件，事件会传递给父视图的onTouchEvent方法进行处理。]]></content>
      <categories>
        <category>android</category>
        <category>view</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDE-AndroidStudio]]></title>
    <url>%2FIDE-AndroidStudio%2F</url>
    <content type="text"><![CDATA[工欲善其事，必先利其器。——《论语·卫灵公》 配置Logcat颜色 Assert：#8F0005 深红Debug：#0070BB 蓝Error：#FF0006 红Info：#48BB31 绿Verbose：#BBBBBB 白Warning：#BBBB23 黄 断点调试与管理 1 Show Execution Point2 Step Over：单步执行。如果当前行为方法调用（不会跳到方法内部），方法执行完后跳到下一行。3 Step Into：与Step Over不同的是，会跳到方法内部（非类库的方法）。4 Force Step Into：与Step Into不同的是，始终跳到方法内部。5 Step Out：跳出方法，返回到该方法调用处。6 Drop Frame7 Run to Cursor8 Resume Program：程序执行到下一个断点处。9 Stop：停止调试。 变量观察 选中变量，右键选择Add to Watches 修改变量值，调试结果。选择Set Value 条件断点循环体内设置。 日志断点Suspend取消选中，显示日志输入框。 异常断点单击如下图标，在弹窗中新建异常断点。 变量断点 方法断点在方法名所在行添加断点。 Plugins]]></content>
      <categories>
        <category>工具</category>
        <category>Android Studio</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-系统架构]]></title>
    <url>%2Fandroid-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[简介Android是一种基于Linux的自由及开放源代码的操作系统，主要使用在智能手机、平板电脑等设备上。下图所示为Android平台的主要组件。 应用程序层用户直接可见的应用程序。 Java API框架您可通过以Java语言编写的API使用Android OS的整个功能集。这些API形成创建Android应用所需的构建块，它们可简化核心模块化系统组件和服务的重复使用，包括以下组件和服务： 丰富、可扩展的视图系统，可用以构建应用的 UI，包括列表、网格、文本框、按钮甚至可嵌入的网络浏览器 资源管理器，用于访问非代码资源，例如本地化的字符串、图形和布局文件 通知管理器，可让所有应用在状态栏中显示自定义提醒 Activity管理器，用于管理应用的生命周期，提供常见的导航返回栈 内容提供程序，可让应用访问其他应用（例如“联系人”应用）中的数据或者共享其自己的数据开发者可以完全访问Android系统应用使用的框架API。 原生C/C++库许多核心Android系统组件和服务（例如ART和HAL）构建自原生代码，需要以C和C++编写的原生库。Android 平台提供Java框架API以向应用显示其中部分原生库的功能。例如，您可以通过Android框架的Java OpenGL API访问OpenGL ES，以支持在应用中绘制和操作2D和3D图形。如果开发的是需要C或C++代码的应用，可以使用Android NDK直接从原生代码访问某些原生平台库。 Android RuntimeAndroid 5.0（API 21）或更高版本，每个应用都在其自己的进程中运行，并且有其自己的Android Runtime（ART）实例。ART编写为通过执行DEX文件在低内存设备上运行多个虚拟机，DEX文件是一种专为Android设计的字节码格式，经过优化，使用的内存很少。编译工具链（例如Jack）将Java源代码编译为DEX字节码，使其可在Android平台上运行。ART的部分主要功能包括： 预先 (AOT) 和即时 (JIT) 编译 优化的垃圾回收 (GC) 更好的调试支持，包括专用采样分析器、详细的诊断异常和崩溃报告，并且能够设置监视点以监控特定字段 Android 5.0（API 21）之前，Dalvik是Android Runtime。如果您的应用在ART上运行效果很好，那么它应该也可在 Dalvik 上运行，但反过来不一定。 Android还包含一套核心运行时库，可提供Java API框架使用的Java 编程语言大部分功能，包括一些Java 8语言功能。 HAL硬件抽象层（HAL）提供标准界面，向更高级别的Java API框架显示设备硬件功能。HAL包含多个库模块，其中每个模块都为特定类型的硬件组件实现一个界面，例如相机或蓝牙模块。当Java API框架要求访问设备硬件时，Android系统将为该硬件组件加载库模块。 相机 蓝牙Android 8.0 架构 Linux kernel使用Linux内核可让Android利用主要安全功能，并且允许设备制造商为著名的内核开发硬件驱动程序。 文章参考https://developer.android.google.cn/guide/platform/]]></content>
      <categories>
        <category>android</category>
        <category>系统架构</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[简介Markdown是一种轻量级的标记语言，将作者从繁杂的排版工作中解放出来，实现易读易写的文章写作。 Windows平台编辑器 MarkdownPad一款全功能的编辑器。 标题 #：H1 ##：H2 ###：H3 文本 加粗：文本左右分别添加两个* 斜体：文本左右分别添加一个* 加粗斜体：文本左右分别添加三个* 删除线：文本左右分别添加两个~ 文本颜色： 1&lt;font color="#ff0000"&gt;颜色文本&lt;/font&gt; 文本增加背景色：文本左右分别添加一个反引号 ` 引用在引用的文本前面添加&gt;，且可以嵌套，&gt;&gt;或&gt;&gt;&gt; 图片 Markdown显示图片语法： 1![图片说明](https://i.imgur.com/4u0hKYA.jpg) 效果如下图： 固定图片显示大小： 1&lt;img src="https://i.imgur.com/4u0hKYA.jpg" width=200 height=200 /&gt; 效果如下图： 图片按比例显示： 1&lt;img src="https://i.imgur.com/4u0hKYA.jpg" width=25% height=25% /&gt; 效果如下图： 链接Markdown显示连接语法：1[链接显示文本]（https://www.baidu.com） 列表 无序列表 有序列表：数字 + . + 空格 第一点 第二点 分隔线一行连续使用三个或以上的-或* 代码 每一行前面加一个tab或4个空格可以标记一个代码片段，效果如下图：public int main() { reutrn 0; } 连续三个反引号`（需要代码高亮的话，加上代码类型），键盘上数字1前面按键，如下图：效果如下图：12345public class main &#123; public static void main(String[] args)&#123; System.out.println("hello java"); &#125; &#125; 表格123|标题1|标题2|标题3||:---|:---:|---:||第一行第一列|01|第一行第三列| 注意：表格语句上一行必须为空行，否则表格无效。效果如下图： 标题1 标题2 标题3 第一行第一列 01 第一行第三列 说明： :-表示居左对齐；:-:表示居中对齐；-:表示居右对齐 -至少有一个 流程图]]></content>
      <categories>
        <category>工具</category>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-adb]]></title>
    <url>%2Fandroid-adb%2F</url>
    <content type="text"><![CDATA[简介Android Debug Bridge（ADB），用于通过电脑端与设备交互。ADB是一个C/S架构的命令行工具，端口5037，如下图所示：adb client：运行在PC端；所有的client都是通过5037端口与adb server进行通信的。adb server：作为一个后台的程序运行在PC端的，负责管理client进程以及adb daemon之间的通信。当一个server开启的时候，会自动绑定并且监听5037端口，接收client通过该端口发送过来的命令。同时server扫描设备端口，进行对已连接设备的定位。adb daemon：每个设备/模拟器连接到PC端时，总会开启这么一个后台进程，并且为其分配了两个连续的端口。端口范围5554-5585，adb连接手机的最大数量是16。偶数端口用于server与设备进行交互的，可以让server直接从设备中读取数据，而奇数端口是用来与设备的adb进行连接通信的。 adb命令adb shell命令]]></content>
      <categories>
        <category>android</category>
        <category>adb</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-versions]]></title>
    <url>%2Fandroid-versions%2F</url>
    <content type="text"><![CDATA[简介android-系统架构 android 9.0 - API 282018年8月7日发布，代号Pie。Android 9.0 Pie WIFI RTT进行室内定位Android 9添加了对IEEE 802.11mc Wi-Fi协议（也称为Wi-Fi Round-Trip-Time(RTT)）的平台支持，从而让您的应用可以利用室内定位功能。在运行Android 9且具有硬件支持的设备上，应用可以使用RTT API来测量与附近支持RTT的Wi-Fi接入点(AP)的距离。设备必须已启用位置服务并开启Wi-Fi扫描（在 Settings &gt; Location 下），同时您的应用必须具有ACCESS_FINE_LOCATION权限。 显示屏缺口支持Android 9支持最新的全面屏，其中包含为摄像头和扬声器预留空间的屏幕缺口。通过DisplayCutout类可确定非功能区域的位置和形状，这些区域不应显示内容。要确定这些屏幕缺口区域是否存在及其位置，请使用 getDisplayCutout()) 函数。 通知动画自动填充框架安全增强功能Android备份无障碍功能旋转文本设备端系统跟踪android 8.1 - API 272017年12月5日发布。 android 8.0 - API 262017年8月22日发布，代号Oreo（奥利奥）。Android 8.0 Oreo android 7.1 - API 252016年12月5日发布。 android 7.0 - API 242016年8月22日发布，代号Nougat（牛轧糖）。Android 7.0 Nougat android 6.0 - API 232015年5月28日发布，代号Marshmallow（棉花糖）。Android 6.0 Marshmallow android 5.1 - API 22android 5.0 - API 212014年10月15日发布，代号Lollipop（）Android 5.0 Lollipop扩展了Android的应用范围，从手机、平板电脑和可穿戴式设备，扩展到电视和汽车。 Material Design以性能为中心通知android 4.4W - API 20android 4.4 - API 19Android 4.4 KitKat android 4.3 - API 18android 4.2-4.2.2 - API 17android 4.1-4.1.1 - API 16android 4.0.3–4.0.4 - API 15android 4.0 - API 14android 3.2 - API 13android 3.1 - API 12android 3.0 - API 11android 2.3.3 - API 10android 2.3 - API 9android 2.2 - API 8android 2.1 - API 7android 2.0.1 - API 6android 1.6 - API 4android 1.5 - API 3android 1.1 - API 2android 1.0 - API 12008年，在Google I/O大会上，谷歌提出了Android HAL架构图。2008年9月，正式发布了Android 1.0系统。 文章参考https://developer.android.google.cn/about/versions/pie/]]></content>
      <categories>
        <category>android</category>
        <category>versions</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机基础-UML类图]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-UML%E7%B1%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[Unified Model Language（UML），统一建模语言。类图用于描述系统中所包含的类以及它们之间的相互关系，帮助人们简化对系统的理解，它是系统分析和设计阶段的重要产物，也是系统编码和测试的重要模型依据。]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>UML类图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-NexT主题配置]]></title>
    <url>%2FHexo-NexT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[小序博客的搭建，可以参考我的博文 搭建个人博客-GitHub-PagesHexo配置文件_config.yml分两种：站点配置文件、主题配置文件。站点配置文件参考Hexo，主题配置文件参考NexT本文主要讲解主题配置文件_config.yml（文件路径：root\themes\next\_config.yml） NexTGitHub hexo-theme-next v6.6.0Site Information Settings设置站点信息favicon:修改网站图标，图片保存在目录\themes\next\source\images中。footer:站点底部 since:2018站点创建时间creative_commons:文章底部添加版权信息 Menu Settings 菜单项（名称和链接） 菜单项的显示文本 菜单项对应的图标。NexT使用的是Font Awesome提供的图标，Font Awesome提供了600+的图标，可以满足绝大多数的场景。 注意：菜单点击可能报Cannot GET **，创建page就可以了，命令如下：12// name为categories、tags、about等，文件存储路径为：root\sourcehexo new page &apos;name&apos; 在source目录下会生成菜单对应文件夹，修改文件夹中的index.md文件，新增type属性，如下：12345---title: 分类date: 2018-12-16 17:03:04type: &quot;categories&quot;--- Scheme SettingsScheme是NexT提供的一种特性，可以设置不同的外观。同时，几乎所有的配置都可以在Scheme之间共用。目前NexT支持以下几种Scheme: Muse-默认Scheme，NexT最初的版本，黑白色调，大量留白 Mist-Muse的紧凑版本，整洁有序的单栏外观 Pisces-双栏Scheme，小家碧玉似的清新 Gemini-左侧网站信息及目录，块+片段结构布局 Sidebar Settings设置侧栏 sidebar:侧栏的位置 sidebar:侧栏显示的时机 avatar:头像 social:社交链接 github_banner:（网站右上角显示关注GitHub图标） Blog rolls友情链接 toc:文章目录 Post Settings reward:打赏 wechat_subscriber:微信订阅 Third Party Services Settingslocal_search:网站添加搜索needmoreshare2:内容分享 在博客根目录执行如下命令： 1git clone https://github.com/theme-next/theme-next-needmoreshare2 themes/next/source/lib/needsharebutton 主题配置文件中，搜索needmoreshare2: 评论系统 畅言 官网 12345# changyanchangyan: enable: false appid: appkey: Valine 官网 DaoVoice修改文章内链接样式在文件\themes\next\source\css_common\components\post\post.styl末尾，添加如下代码：1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; //原始链接颜色 border-bottom: none; border-bottom: 1px solid #0593d3; //底部分割线颜色 &amp;:hover &#123; color: #fc6423; //鼠标经过颜色 border-bottom: none; border-bottom: 1px solid #fc6423; //底部分割线颜色 &#125;&#125; 修改文章底部带#的标签实现效果图： \themes\next\layout_macro\post.swig中找到rel=”tag”&gt;#，将#替换为1&lt;i class="fa fa-tag"&gt;&lt;/i&gt; 文章末尾添加结束标语实现效果图： \themes\next\layout_macro中新建passage-end-tag.swig文件，添加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;-------------本文结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 打开\themes\next\layout_macro\post.swig文件，在post-body后，post-footer前，添加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 修改主题配置文件_config.yml，末尾添加如下内容： 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 网站底部添加总访客量、总访问量方法一： 打开\themes\next\layout_partials\footer.swig文件，在copyright之前添加如下代码：1&lt;script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 单个用户连续点击n篇文章，记录n次访问量。123&lt;span id="busuanzi_container_site_pv"&gt; 总访问量&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;次&lt;/span&gt; 单个用户连续点击n篇文章，只记录1次访客数。123&lt;span id="busuanzi_container_site_uv"&gt; 总访客数&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;人次&lt;/span&gt; 方法二：主题配置文件_config.yml，搜索busuanzi_count:注：本地预览时，数字存在异常，部署云端即可恢复正常。 网站底部添加字数统计npm install hexo-wordcount –save打开文件\themes\next\layout_partials\footer.swig，末尾加上如下代码：1234&lt;div class="theme-info"&gt; &lt;div class="powered-by"&gt;&lt;/div&gt; &lt;span class="post-count"&gt;全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 点击出现爱心效果 在目录\themes\next\source\js\src中新建文件love.js，添加如下代码： 1!function (e, t, a) &#123; function n() &#123; c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"), o(), r() &#125; function r() &#123; for (var e = 0; e &lt; d.length; e++)d[e].alpha &lt;= 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y-- , d[e].scale += .004, d[e].alpha -= .013, d[e].el.style.cssText = "left:" + d[e].x + "px;top:" + d[e].y + "px;opacity:" + d[e].alpha + ";transform:scale(" + d[e].scale + "," + d[e].scale + ") rotate(45deg);background:" + d[e].color + ";z-index:99999"); requestAnimationFrame(r) &#125; function o() &#123; var t = "function" == typeof e.onclick &amp;&amp; e.onclick; e.onclick = function (e) &#123; t &amp;&amp; t(), i(e) &#125; &#125; function i(e) &#123; var a = t.createElement("div"); a.className = "heart", d.push(&#123; el: a, x: e.clientX - 5, y: e.clientY - 5, scale: 1, alpha: 1, color: s() &#125;), t.body.appendChild(a) &#125; function c(e) &#123; var a = t.createElement("style"); a.type = "text/css"; try &#123; a.appendChild(t.createTextNode(e)) &#125; catch (t) &#123; a.styleSheet.cssText = e &#125; t.getElementsByTagName("head")[0].appendChild(a) &#125; function s() &#123; return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")" &#125; var d = []; e.requestAnimationFrame = function () &#123; return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) &#123; setTimeout(e, 1e3 / 60) &#125; &#125;(), n() &#125;(window, document); 打开文件\themes\next\layout_layout.swig，末尾加上如下代码： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 添加网易云音乐\themes\next\layout_macro\sidebar.swig 添加依赖在目录\themes\next下，开启Git Bash，执行命令。 设置动态背景canvas_nest:1git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest 站点顶部进度条pace:1git clone https://github.com/theme-next/theme-next-pace source/lib/pace 参考文章https://sun_xy.gitee.io/blog/2018/10/16/hexo_next_blog/http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.htmlhttps://thief.one/2017/03/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/]]></content>
      <categories>
        <category>搭建环境</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客-GitHub-Pages]]></title>
    <url>%2F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-GitHub-Pages%2F</url>
    <content type="text"><![CDATA[小序 创建GitHub Pages 安装Git 安装Node.js GitHub Pages 注册GitHub账号，新建仓库，仓库名格式为（用户名.github.io），用户名必须与GitHub保持一致。 仓库中点击Settings菜单，找到GitHub Pages Choose a theme 静态博客框架Hexo简介Hexo是一个快速、简洁且高效的博客框架。使用Markdown解析文章，在几秒内，即可利用靓丽的主题生成静态网页。Hexo官网Windows搭建Hexo博客系统并部署到GitHub 安装hexo本地环境，使用命令：npm install -g hexo 计算机本地新建保存博客文件夹 初始化hexo博客工程：hexo init 执行编译与预览命令后，hexo预览http://localhost:4000/ 命令官方文档 themes主题设置 博客根目录：git clone https://github.com/theme-next/hexo-theme-next themes/next 修改站点配置文件_config.yml中theme为目标主题名称theme-NexT主题配置文件_config.yml scheme:目前NexT支持四种Scheme menu:设置菜单 sidebar:设置侧边栏 avatar:设置头像 favicon:设置网站缩略图 新建博客hexo n “博客名称” 部署 安装Hexo部署插件：npm install hexo-deployer-git –save 修改配置文件_config.yml，在deploy下指定仓库路径和部署的协议 hexo g hexo d Pluginshexo-admin官网npm install hexo-admin –save hexo-tocnpm install hexo-toc –save jekylljekyll jekyll themes]]></content>
      <categories>
        <category>搭建环境</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件-面向对象六大原则]]></title>
    <url>%2F%E8%BD%AF%E4%BB%B6-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[小序系统开发过程中，最难的不是完成系统的开发工作，而是在于后续的升级、维护过程中让系统能够拥抱变化。拥抱变化也就意味着在满足需求且不破坏系统稳定性的前提下保持高可扩展性、高内聚、低耦合，经历各版本的变更之后依然保持清晰、灵活、稳定的系统架构。当然，这是比较理想的情况，但我们必须朝着这个方向去努力，那么遵循面向对象六大原则就是我们走向灵活软件之路所迈出的第一步。 软件的可维护性和可复用性。 好的系统设计应该具备如下三个性质： 可扩展性（Extensibility） 灵活性（Flexibility） 可插入性（Pluggability） 可维护性较低的系统设计，通常有如下几个原因： 复用率低（Immobility） 黏度过高（Viscosity） 脆弱 僵硬 常用的面向对象设计原则包括7个，这些原则并不是孤立存在的，它们相互依赖，相互补充。 开闭原则（OCP）Open Close Principle，缩写OCP。开闭原则由Bertrand Meyer（勃兰特·梅耶）于1988年出版的《面向对象软件构造》一书中提出。抽象化是开闭原则的关键。 定义：软件中的对象（类、模块、函数等）应该对于扩展是开放的，对于修改是封闭的。 软件开发过程中，最不会变化的就是变化本事。 依赖倒置原则（DIP）Dependence Inversion Principle，缩写DIP。 定义：依赖倒置原则指代了一种特定的解耦形式，使得高层次的模块不依赖于低层次模块的实现细节的目的，依赖模块被颠倒了。 高层模块不应该依赖低层模块，两者都应该依赖其抽象 抽象不应该依赖细节 细节应该依赖抽象 java语言中，抽象就是指接口或抽象类，两者都不可以直接被实例化；细节就是实现类。高层模块就是调用端，低层模块就是具体实现类。 里氏替换原则（LSP）Liskov Substitution Principle，缩写LSP。 定义：所有引用基类的地方必须能透明地使用其子类的对象。 单一职责原则（SRP）Single Responsibility Principle，缩写SRP。 定义：就一个类而言，应该仅有一个引起它变化的原因。 接口隔离原则（ISP）InterfaceSegregation Principles，缩写ISP。 定义：客户端不应该依赖它不需要的接口。 迪米特原则（LOD）Law of Demeter，缩写LOD，也称为最少知识原则。 定义：一个对象应该对其他对象有最少的了解。 Only talk to your immedate friends。只与直接的朋友通信。？？？每个对象都必然会与其他对象有耦合关系，两个对象之间的耦合就称为朋友关系，如依赖、关联、组合、聚合等。 类应该对自己需要耦合或调用的类知道得最少，类的内部如何实现与调用者或依赖者没有关系，调用者或者依赖者只需要知道它需要的方法即可，其他的可一概不用管。类与类之间关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。软件总的原则：低耦合、高内聚。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>面向对象六大原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
