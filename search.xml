<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[虚拟机类加载机制]]></title>
    <url>%2F%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。 Class类文件的结构Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。 类加载机制虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。 类加载生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。其中验证、准备、解析3个部分统称为连接。 虚拟机规范严格规定了有且只有5种情况必须立即对类进行初始化： 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。 使用java.lang.reflect包的方法对类进行反射调用的时候 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类。 加载验证准备解析初始化类加载器从Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器，这个类加载器使用C++语言实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。 参考 深入理解Java虚拟机 第2版]]></content>
      <categories>
        <category>java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨平台技术分析]]></title>
    <url>%2F%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[简介根据跨平台原理，可以分为如下几类： HTML5+原生+Cordova JavaScript+原生渲染（React Native、Weex、快应用） 自绘引擎（Flutter） Vue.js(2013)React Native(2015)Facebook在2015.9.15发布了React Native for Android，把JavaScript开发技术扩展到了Android平台。http://reactnative.dev/React Native中文网：https://reactnative.cn/项目地址：https://github.com/facebook/react-native Weex(2016) A framework for building Mobile cross-platform UI. Weex于2017年2月24日迁移至Apache基金会。 官网：https://weex.apache.org/项目地址：https://github.com/apache/incubator-weexWeex中文讨论网站：https://segmentfault.com/t/weex Flutter(2018) Flutter makes it easy and fast to build beautiful mobile apps. Flutter中文网：https://flutterchina.club/项目地址：https://github.com/flutter/flutter]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[软件架构详解]]></title>
    <url>%2F%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[引言 软件架构（Software Architecture）是一系列相关的抽象模式，用于指导大型软件系统各个方面的设计。软件架构是一个系统的草图。软件架构描述的对象是直接构成系统的抽象组件。各个组件之间的连接则明确和相对细致地描述组件之间的通讯。在实现阶段，这些抽象组件被细化为实际的组件，如具体某个类或对象。轻量级JavaEE（Struts+Spring+Hibernate）重量级JavaEE（JSF+EJB+JPA） 架构模式是描述软件系统里的基本的结构组织或纲要。从定义上来看，它是在指导我们如何组织代码，是一种具有指导意义的思想，如解决系统的数据与显示分离的问题，AOP、IOC、ORM、MVC等。 框架是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法；另一种定义认为，框架是可被应用开发者定制的应用骨架。前者是从应用方面而后者是从目的方面给出的定义。Struts、MyBatis等。 设计模式是一套被反复使用、多数人知道的、经过分类编目的、代码设计经验的总结。从定义上看，它涉及到了代码级别，侧重于解决实际的现实问题。 分层架构分层架构（layered architecture）是最常见的软件架构，也是事实上的标准架构。将软件分成若干个水平层，每一层都有清晰的角色和分工，不需要知道其他层的细节。层与层之间通过接口通信。虽然没有明确约定，软件一定要分成多少层，但是四层的结构最常见。 表现层（presentation）：用户界面，负责视觉和用户互动 业务层（business）：实现业务逻辑 持久层（persistence）：提供数据，SQL语句放在这一层 数据层（database）：保存数据 事件驱动架构事件驱动架构（Event Driven Architecture，EDA）一个事件驱动框架（EDA）定义了一个设计和实现一个应用系统的方法学，在这个系统里事件可传输于松散耦合的组件和服务之间。 微核架构微核架构（microkernel architecture）又称为”插件架构”（plug-in architecture），指的是软件的内核相对较小，主要功能和业务逻辑都通过插件实现。内核（core）通常只包含系统运行的最小功能。插件则是互相独立的，插件之间的通信，应该减少到最低，避免出现互相依赖的问题。优点： 良好的功能延伸性（extensibility），需要什么功能，开发一个插件即可 功能之间是隔离的，插件可以独立的加载和卸载，使得它比较容易部署 可定制性高，适应不同的开发需要 可以渐进式地开发，逐步增加功能 缺点： 扩展性（scalability）差，内核通常是一个独立单元，不容易做成分布式 开发难度相对较高，因为涉及到插件与内核的通信，以及内部的插件登记机制 微服务架构微服务架构（microservices architecture）是服务导向架构（service-oriented architecture，缩写 SOA）的升级。每一个服务就是一个独立的部署单元（separately deployed unit）。这些单元都是分布式的，互相解耦，通过远程通信协议（比如REST、SOAP）联系。 云架构云结构（cloud architecture）主要解决扩展性和并发的问题，是最容易扩展的架构。它的高扩展性，主要原因是没使用中央数据库，而是把数据都复制到内存中，变成可复制的内存数据单元。然后，业务处理能力封装成一个个处理单元（prcessing unit）。访问量增加，就新建处理单元；访问量减少，就关闭处理单元。由于没有中央数据库，所以扩展性的最大瓶颈消失了。由于每个处理单元的数据都在内存里，最好要进行数据持久化。这个模式主要分成两部分：处理单元（processing unit）和虚拟中间件（virtualized middleware）。 处理单元：实现业务逻辑 虚拟中间件：负责通信、保持sessions、数据复制、分布式处理、处理单元的部署。]]></content>
      <categories>
        <category>软件架构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java内存模型]]></title>
    <url>%2Fjava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[概述Java虚拟机规范中试图定义一种Java内存模型（JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。经过长时间的验证和修订，在JDK 1.5（实现了JSR-133）发布后，Java内存模型已经成熟和完善起来了。 主内存与工作内存Java内存模型规定了所有的变量都存储在主内存中，每个线程都有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。 volatile变量定义为volatile之后，具备两种特性： 保证此变量对所有线程的可见性，当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。 禁止指令重排序优化，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。 内存屏障（指令重排时不能把后面的指令重排序到内存屏障之前的位置） volatile变量的运算在并发下是安全的？volatile变量在各个线程的工作内存中不存在一致性问题（在各个线程的工作内存中，volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题），但是java里面的运算并非原子操作（i++），导致volatile变量的运算在并发下一样是不安全的。 原子性、可见性与有序性Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的。 原子性 可见性：可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。 有序性 参考 深入理解Java虚拟机 第2版]]></content>
      <categories>
        <category>java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java垃圾收集器与内存分配策略]]></title>
    <url>%2Fjava%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[概述 哪些内存需要回收？ 什么时候回收？ 如何回收？ 程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。而java堆和方法区则不一样，只有在程序运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。 内存泄漏：分配的内存得不到及时回收。Java程序的内存分配和回收都是由JRE在后台自动进行的。（垃圾回收GC）JRE会提供一个后台线程来进行检测和控制。 【对象是否存活算法】引用计数算法主流的java虚拟机没有选用引用计数算法来管理内存，主要的原因是它很难解决对象之间相互循环引用的问题。 可达性分析算法基本思路是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。java语言中，可作为GC Roots的对象包括下面几种： 虚拟机栈中引用的对象。 方法区中类静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中JNI引用的对象。 引用 强引用：只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 软引用：SoftReference，系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。 弱引用：WeakReference，当垃圾收集器工作时，不管当前内存是否足够，总会回收该对象所占用的内存。 虚引用：PhantomReference，完全类似于没有引用。主要用于跟踪对象被垃圾回收的状态，不能单独使用，必须和引用队列联合使用。 【垃圾收集算法】标记-清除算法该算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。缺点： 效率低 空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。缺点：复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。 标记-整理算法标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 分代收集算法一般将java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法。老生代中，对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-整理”算法来进行回收。 【垃圾收集器】如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。 【内存分配】大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。 参考 深入理解Java虚拟机 第2版]]></content>
      <categories>
        <category>java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java虚拟机内存结构]]></title>
    <url>%2Fjava%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[概述Java虚拟机（JVM，Java Virtual Machine）在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。Java虚拟机所管理的内存包括以下几个运行时数据区： 程序计数器 Java虚拟机栈 本地方法栈 Java堆 方法区 直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。 程序计数器程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说就是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 Java虚拟机栈与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。注意：Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。 本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。有的虚拟机（Sun HotSpot）直接把本地方法栈和虚拟机栈合二为一。 堆对于大多数应用来说，java堆是java虚拟机所管理的内存中最大的一块。java堆是被所有线程共享的内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。java虚拟机规范中的描述：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也逐渐变得不是那么“绝对”了。Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区。 方法区方法区与java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。运行时常量池是方法区的一部分。 栈与堆的区别参考 深入理解Java虚拟机 第2版]]></content>
      <categories>
        <category>java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-性能篇-内存泄漏]]></title>
    <url>%2Fandroid-%E6%80%A7%E8%83%BD%E7%AF%87-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。 java虚拟机内存管理运行时数据区 所有线程共享的数据区：方法区（存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据）、堆（存放对象实例） 独享：虚拟机栈（执行java方法服务）、本地方法栈（Native方法服务）、程序计数器 优化分为两个方面 开发过程中避免写出有内存泄漏的代码（制定编码规范） 借助一些分析工具找出潜在的内存泄漏 触发场景持有activity对象 单例模式 静态变量 匿名内部类 属性动画 使用Handler，Activity销毁时removeCallbacksAndMessages(null); 资源未关闭（如数据库游标没有关闭，文件流没有关闭） Bitmap 分析工具LeakCanaryhttps://github.com/square/leakcanary]]></content>
      <categories>
        <category>android</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-性能优化]]></title>
    <url>%2Fandroid-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[代码优化 避免创建过多的对象，进行过多的内存分配操作； 不要过多使用枚举，枚举占用的内存空间要比整型大； 常量请使用static final来修饰； 使用Android特有的数据结构，比如SparseArray和Pair等； 适当使用软引用和弱引用； 采用内存缓存和磁盘缓存； 尽量采用静态内部类，避免潜在的由于内部类而导致的内存泄漏。 java引用 强引用 软引用：当内存空间不足时，对象才被回收。 弱引用：不论当前内存空间是否不足，都回收。 虚引用：本质只是标记，跟踪对象被垃圾回收的活动。 线程优化线程优化的思想是采用线程池，避免程序中存在大量的Thread。 线程池可以重用内部的线程，从而避免了线程的创建和销毁所带来的性能开销。 线程池可以有效控制线程池的最大并发数，避免大量的线程因互相抢占资源从而导致阻塞现象的发生。 布局优化 include标签：共享布局。 merge 标签：减少布局层次。 ViewStub 标签：实现延迟加载，使用的时候再加载，提高了程序初始化时的性能。 尽量使用CompoundDrawable 使用Lint 绘制优化View的onDraw方法要避免执行大量的操作。 不要创建新的局部对象，因为onDraw方法可能会被频繁调用，会在一瞬间产生大量的临时对象，不仅占用了内存而且还会导致系统更加频繁gc，降低了程序的执行效率。 不要做耗时的任务，也不能执行成千上万次的循环操作，尽管每次循环都很轻量级，但是大量的循环仍然十分抢占CPU的时间片，这会造成View的绘制过程不流畅。Google官方给出的性能优化典范中的标准，View的绘制帧率保证60fps是最佳的，这就要求每帧的绘制时间不超过16ms（1000/60），虽然程序很难保证16ms这个时间，但是尽量降低onDraw方法的复杂度总是切实有效的。 响应速度优化响应速度优化的核心思想是避免在主线程中做耗时操作。如果在主线程中做太多事情，会导致Activity启动时出现黑屏现象，甚至出现ANR。Android规定，Activity如果5秒之内无法响应屏幕触摸事件或键盘输入事件就会出现ANR，而BroadcastReceiver如果10秒内还未执行完操作也会出现ANR。定位ANR？当一个进程发生ANR以后，系统会在/data/anr目录下创建一个文件traces.txt。 图片优化图片格式JPEG、PNG、GIF、BMP、WebP（Android 4.0）应用开发中能够使用的编码格式只有三种：JPEG、PNG、WebP，图片格式可以通过查看Bitmap类的CompressFormat确定。应用层使用GIF格式，需引入第三方库。 JPEG：有损压缩图像标准格式，不支持透明和多帧动画。 PNG：无损压缩图片格式，支持完整的透明通道，从图像处理领域讲，JPEG只有RGB三个通道，而PNG有ARGB四个通道。 GIF：古老的图片格式，诞生于1987。支持多帧动画。 WebP：Google在2010年发布，支持有损和无损压缩、支持完整的透明通道、也支持多帧动画。 图片压缩PNG图片压缩工具： 无损压缩ImageOptim：通过优化PNG压缩参数，移除冗余元数据以及非必需的颜色设置文件等方式。 有损压缩ImageAlpha 有损压缩TinyPNG PNG/JPEG转换为WebP：4.0以上直接使用，以下通过第三方库Webp-android-backport实现。Google测试，无损压缩后的WebP比PNG 文件少了45%的文件大小，通过其他压缩工具之后，依然减少约28%的文件大小。WebP转换的工具可以选择智图和iSparta等。 尽量使用NinePatch格式的PNG图：.9.png 图片缓存网络优化避免DNS解析DNS是域名系统，根据应用请求所用的域名URL去网络映射表中查找对应IP地址，可能需要上百毫秒，可能存在DNS劫持的危险。 合并网络请求一次完整的HTTP请求，首先进行DNS查找，接着通过TCP三次握手，从而建立连接；如果是HTTPS请求，还需要经过TLS握手成功后连接才建立。 离线缓存Android中，典型的是使用LruCache实现内存缓存，DiskLruCache实现外存缓存。 压缩数据大小减少网络上面传输的数据，对于客户端来说，可以对发送给服务端的数据进行gzip压缩；同时选用更优的数据传输格式。 合理选择超时策略监听ConnectivityManager.CONNECTIVITY_ACTION变化获取最新的网络类型。 使用CDNCDN全称是内容分发网络，基本思想是尽可能避开网络上可能影响数据传输速度和稳定性的环节，从而实现更快、更稳定的数据传输。CDN加速能够缓解电信核心网络延迟带来的影响。 电量优化]]></content>
      <categories>
        <category>android</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-加密]]></title>
    <url>%2Fjava-%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[Base64Base64最早应用于解决电子邮件传输的问题。Base64基于64个字符的编码算法，（A-Z,a-z,0-9,+/=）最后一个字符是等号，它是用来补位的。 消息摘要算法消息摘要算法包含MD（Message Digest，消息摘要算法）、SHA（Secure Hash Algorithm，安全散列算法）和MAC（Message Authentication Code，消息认证码算法）共3大系列，常用于验证数据的完整性，是数字签名算法的核心算法。消息摘要算法一直是非对称加密算法中一项举足轻重的关键性算法。消息摘要算法又称为散列算法，其核心在于散列函数的单向性。通过散列函数可得到对应的散列值，不可反推。 MD5MD5算法是典型的消息摘要算法，其前身有MD2、MD3和MD4算法。不论是哪种MD算法，都需要获得一个随机长度的信息并产生一个128位的信息摘要。 SHASHA算法基于MD4算法基础上，新一代的消息摘要算法。与MD算法不同之处在于摘要长度，SHA算法的摘要长度更长，安全性更高。SHA算法目前共有SHA-1、SHA-224、SHA-256、SHA-384和SHA-512五种算法，通常将后四种算法称为SHA-2算法。 MAC对称加密算法对称密码体制要求加密与解密使用同一个共享密钥，解密是加密的逆运算。 DES三重DESAES非对称加密算法非对称密码体制的加密密钥和解密密钥不相同，分为公钥与私钥。 RSA第一个既能用于数据加密也能用于数字签名的算法。 数字签名算法数字签名算法可以看做是一种带有密钥的消息摘要算法，并且这种密钥包含了公钥和私钥。也就是说，数字签名算法是非对称加密算法和消息摘要算法的结合体。 RSADSAECDSA数字证书安全协议HTTPS协议（附加了SSL/TLS协议的HTTP协议）为数字证书提供了最佳的应用环境。 参考 《Java加密与解密的艺术》]]></content>
      <categories>
        <category>java</category>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-框架篇-全家桶]]></title>
    <url>%2Fandroid-%E6%A1%86%E6%9E%B6%E7%AF%87-%E5%85%A8%E5%AE%B6%E6%A1%B6%2F</url>
    <content type="text"><![CDATA[网络 名称 开发者 时间 备注 Retrofit Square JakeWharton OkHttp Square 2013-05-06 Volley Google 2013 适合数据量大，需要频繁通信的网络操作。不适用文件的上传下载操作。 Android-Async-Http Apache HttpClient Apache API 23:Android 6.0上被删除 HttpURLConnection JDK java.net包下 异步分发通信 名称 开发者 时间 备注 RxJava AsyncTask Google 原生 图片加载 名称 开发者 时间 Fresco Facebook 2015年3月 Glide Google 2014年 Picasso Square 2013年2月 Universal-Image-Loader nostra13 2011年9月 日志打印ARouterRxPermissionsDagger2LitePalButterKnife]]></content>
      <categories>
        <category>android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨平台-框架篇-Vue]]></title>
    <url>%2F%E8%B7%A8%E5%B9%B3%E5%8F%B0-%E6%A1%86%E6%9E%B6%E7%AF%87-Vue%2F</url>
    <content type="text"><![CDATA[概览官网：https://cn.vuejs.org/项目地址：https://github.com/vuejs更新日志：https://github.com/vuejs/vue/releases兼容性：Vue 不支持 IE8 及以下版本，因为 Vue 使用了 IE8 无法模拟的 ECMAScript 5 特性。但它支持所有兼容 ECMAScript 5 的浏览器。Vue Devtools：在使用 Vue 时，我们推荐在你的浏览器上安装 Vue Devtools。它允许你在一个更友好的界面中审查和调试Vue应用。 Vue CLIVue CLI：https://cli.vuejs.org/zh/是一个基于 Vue.js 进行快速开发的完整系统。项目地址：https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue @vue/cli @vue/cli-service 项目目录│ .babelrc（babel编译参数）│ .editorconfig（代码格式）│ .eslintignore│ .eslintrc.js│ .gitignore│ .postcssrc.js（转换css工具）│ index.html（主页）│ package.json（项目配置）│ README.md（项目说明）│├─build（webpack相关配置文件）│ build.js（生产环境构建）│ check-versions.js（检查npm、node版本）│ logo.png│ utils.js│ vue-loader.conf.js│ webpack.base.conf.js（webpack基础配置）│ webpack.dev.conf.js（webpack开发环境配置）│ webpack.prod.conf.js（webpack生产环境配置）│├─config（vue基本配置文件）│ dev.env.js（项目开发环境配置）│ index.js（项目主要配置）│ prod.env.js（项目生产环境配置）│ test.env.js│├─src│ │ App.vue（根组件）│ │ main.js（入口文件）│ ││ ├─assets│ │ logo.png│ ││ ├─components（公共组件）│ │ HelloWorld.vue│ ││ └─router（路由）│ index.js│├─static（静态资源） package.json文件： scripts：指定了运行脚本命令的npm命令行缩写 dependencies：项目运行所依赖的模块 devDependencies：项目开发所需要的模块 12npm install &lt;package_name&gt; --savenpm install &lt;package_name&gt; --save-dev @vue/cli (3.x)安装：123npm install -g @vue/cli# ORyarn global add @vue/cli vue-cli (1.x or 2.x)https://github.com/vuejs/vue-cli/tree/v2#vue-cli–安装：1npm install -g vue-cli Vue Routerhttps://router.vuejs.org/zh/ 环境安装开发工具： WebStorm Node.js（npm将自动安装） 配置开发环境：https://npm.taobao.org/ 安装淘宝镜像：npm install -g cnpm –registry=https://registry.npm.taobao.org 安装webpack：cnpm install -g webpack 安装vue-cli：cnpm install -g vue-cli，验证命令vue -V main.js123456789101112131415// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from 'vue'import App from './App'import router from './router'Vue.config.productionTip = false/* eslint-disable no-new */new Vue(&#123; el: '#app', router, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm详解]]></title>
    <url>%2Fnpm%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[https://www.npmjs.cn/config12345678// 如：key=registry，设置地址npm config set &lt;key&gt; &lt;value&gt;// 如：key=registry，默认地址：https://registry.npmjs.org/npm config get &lt;key&gt;npm config listnpm config edit install123456// 升级npmnpm install npm@latest -g// 本地安装，在当前的目录下创建一个 node_modules 的目录npm install &lt;package_name&gt;// 全局安装，npm install -g &lt;package_name&gt; root12// npm根目录npm root [-g] uninstall12// 全局卸载npm uninstall -g &lt;package_name&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-框架篇-Spring]]></title>
    <url>%2Fjava-%E6%A1%86%E6%9E%B6%E7%AF%87-Spring%2F</url>
    <content type="text"><![CDATA[概述Spring是于2003年兴起的一个轻量级的Java开发框架，由Rod Johnson创建。解决的是业务逻辑层和其他各层的松耦合问题。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。 EJB -&gt; Spring Framework -&gt; Spring Boot -&gt; Spring Cloud Spring Initializr:https://start.spring.io/ 优点体系结构Spring Framework下载jar包：http://repo.springsource.org/libs-release-local/org/springframework/spring/3.2.0.RELEASE/spring-framework-3.2.0.RELEASE-dist.zip项目地址：https://github.com/spring-projects/spring-framework Spring Boot项目地址：https://github.com/spring-projects/spring-boot Spring Cloud]]></content>
      <categories>
        <category>java</category>
        <category>java EE</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java EE知识框架]]></title>
    <url>%2FjavaEE%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[概述Java EE（Java Platform Enterprise Edition，Java平台企业版），最初称为J2EE，2018年3月更名为Jakarta EE。是Sun公司为企业级应用推出的标准平台，用来开发B/S架构软件。Java EE是一系列技术和标准的集合，它包括了从前端Web界面到中间件，再到后端数据库系统的一系列技术和规范。 开发工具 IntelliJ IDEA Tomcat（应用服务器） MySQL、Oracle（SQLyog，Navicat） JSPJSP（Java Server Pages），其根本是一个简化的Servlet设计。JSP页面内容由两部分组成： 静态部分：标准的HTML标签、静态的页面内容。 动态部分：&lt;%%&gt; JSP文件必须在JSP服务器内运行。 JSP文件必须生成Servlet才能执行。 每个JSP页面的第一个访问者速度很慢，因为必须等待JSP编译成Servlet。 基本语法 JSP声明的语法格式：&lt;%! 声明部分 %&gt; JSP输出表达式语法格式：&lt;%=表达式%&gt; JSP注释格式：&lt;%-- 注释内容 --%&gt; JDBC JDBC（Java DataBase Connectivity，java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问。 持久化（Persistence），数据保存到可掉电式存储设备中以供之后使用。 发展历程： JDBC -&gt; JDO -&gt; Hibernate JDBC API包括两个层次： 面向应用的API：JDBC API，提供了应用程序对JDBC的管理连接。java.sql.* 面向数据库的API：Java Driver API，支持JDBC管理到驱动器连接。 JDBC API常用接口和类： Connection：表示与数据库创建的连接 DriverManager：注册驱动 Statement：操作数据库sql语句的对象 ResultSet：结果集或一张虚拟表 JDBC URL示例：jdbc:mysql://localhost:3306/test java后台开发路线 编程语言 网络请求 数据库 基本算法 设计模式 应用框架 中间件 推荐书籍： Java编程思想 Java并发编程实战 深入理解Java虚拟机 函数式编程思维 TCP/IP详解 鸟哥的Linux私房菜 Spring技术内幕 Elasticsearch服务器开发 工具： Git/SVN（版本控制） Jenkins（持续集成） Maven（项目管理工具） 体系结构从上到下分别是表现层（Web）、业务层（Service）、持久层（DAO，提供数据，SQL语句）。Struts和SpringMVC是Web层的框架，Spring是业务层的框架，Hibernate和MyBatis是持久层的框架。 项目结构： Web表现层 MVCM：ModelV：View，jspC：Controller，servletservicedao ServletFilter[SSH框架]Spring + Struts/Struts2 + Hibernate Struts2Struts1核心控制器就是一个Servlet。2005年之前流行Struts2以WebWork为核心，采用拦截器的机制来处理用户的请求。 下载Struts2开发包 http://struts.apache.org Hibernate传统的Java应用都是采用JDBC来访问数据库的，但传统的JDBC采用的是一种基于SQL的操作方式，这种操作方式与Java语言的面向对象特征不太一致，所以Java EE应用需要一种技术，通过这种技术能让Java以面向对象的方式操作关系数据库。ORM（Object Relation Mapping），最早的ORM是Entity EJB（Enterprise JavaBean），许多人觉得EJB非常繁琐。这种背景下，Hibernate框架应运而生。 [SSM框架]Spring + Spring MVC + Mybatis SpringSpringMVCSpringMVC是Spring实现的一个Web层，相当于Struts的框架，但是比Struts更加灵活和强大 MybatisMybatis是一个持久层的框架，在使用上相比Hibernate更加灵活，可以控制sql的编写，使用XML或注解进行相关的配置。 [数据库]Redis(高速缓存)MongoDBMongoDB Elasticsearch[微服务架构]DubboSpring CloudZookeeper[容器技术]DockerDocker 是一个开源的应用容器引擎，让开发者可以打包应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化，容器是完全使用沙箱机制，相互之间不会有任何接口。 K8sKubernetes 是容器集群管理系统，是一个开源的平台，可以实现容器集群的自动化部署、自动扩缩容、维护等功能。 KafkaKafka 是一个分布式消息队列。具有高性能、持久化、多副本备份、横向扩展能力。生产者往队列里写消息，消费者从队列里取消息进行业务逻辑。一般在架构设计中起到解耦、削峰、异步处理的作用。 高并发负载均衡其他消息队列缓存技术Node.js]]></content>
      <categories>
        <category>java</category>
        <category>java EE</category>
      </categories>
      <tags>
        <tag>java EE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-框架篇-OkHttp]]></title>
    <url>%2Fandroid-%E6%A1%86%E6%9E%B6%E7%AF%87-OkHttp%2F</url>
    <content type="text"><![CDATA[概览官网https://square.github.io/okhttp/项目地址https://github.com/square/okhttpMavenhttps://search.maven.org/artifact/com.squareup.okhttp3/okhttp 工作原理源码解析历史版本4.xhttps://square.github.io/okhttp/changelog/ 4.4.0（2020-02-17）4.3.0（2019-12-31）4.2.0（2019-09-10）4.1.0（2019-08-12）4.0.0（2019-06-26）https://square.github.io/okhttp/upgrading_to_okhttp_4/ 4.0.0-RC3（2019-06-24）4.0.0-RC2（2019-06-21）4.0.0-RC1（2019-06-03）First stable preview of OkHttp 4.4.0.0-alpha01（2019-05-09） 3.xhttps://square.github.io/okhttp/changelog_3x/ 3.14.0（2019-03-14）3.5.0（2016-12-02）3.4.1（2016-07-10）3.0.0（2016-01-13）3.0.0-RC1（2016-01-02）改变项目的包名com.squareup.okhttp为okhttp3。12// Maven group ID为com.squareup.okhttp3implementation 'com.squareup.okhttp3:okhttp:3.x.x' https://jakewharton.com/java-interoperability-policy-for-major-version-updates/For major version updates in significantly foundational libraries we will take the following steps: 重命名java包名为包括版本号 将库名作为Maven group ID的一部分 重命名Maven group ID包含版本号 2.xhttps://square.github.io/okhttp/changelog_2x/ 2.0.0（2014-06-21）2.0.0-RC1（2014-05-23）1.xhttps://square.github.io/okhttp/changelog_1x/ 1.6.0（2014-05-23）1.5.0（2014-03-07）1.0.0（2013-05-06）Initial release.12345&lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;version&gt;(insert latest version)&lt;/version&gt;&lt;/dependency&gt;]]></content>
      <categories>
        <category>android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-AndroidX]]></title>
    <url>%2Fandroid-AndroidX%2F</url>
    <content type="text"><![CDATA[概览 We hope the division between android.* and androidx.* makes it more obvious which APIs are bundled with the platform, and which are static libraries for app developers that work across different versions of Android. Android 9.0（API 28）发布后，新版支持库AndroidX也随之诞生，它属于Jetpack。 简单地说就是新的库可以在不同的Android版本上使用。之前的话，所有support依赖库版本必须一致，如果有bug，所有依赖库版本都需要升级，存在绑定关系，且正式版的发布周期也很长。 androidx软件包使用严格的语义版本控制 官方参考地址：AndroidX OverviewMigrating to AndroidX（迁移到AndroidX）Recent Release NotesAPI reference：AndroidX 使用与迁移新项目中使用AndroidX，需要将编译SDK设置为Android 9.0（API 28）或更高版本，并在gradle.properties文件中将以下两个Android Gradle插件标记设置为true。1234# 当前项目启用AndroidXandroid.useAndroidX=true# 是否迁移之前的依赖包android.enableJetifier=true Android Studio 3.2 Canary中添加了一键迁移的功能 Refactor -&gt; Migrate to AndroidXProperties]]></content>
      <categories>
        <category>android</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-Constraint Layout Library]]></title>
    <url>%2Fandroid-ConstraintLayoutLibrary%2F</url>
    <content type="text"><![CDATA[简介 Android Studio版本至少2.3； 添加依赖，如下：1implementation 'com.android.support.constraint:constraint-layout:1.1.3' ConstraintLayout1package android.support.constraint; ConstraintLayout 主要是为了解决布局嵌套过多的问题，以灵活的方式定位和调整小部件。Android Studio 2.3开始，官方模板默认使用ConstraintLayout。 相对定位 layout_constraintLeft_toLeftOf layout_constraintLeft_toRightOf layout_constraintRight_toLeftOf layout_constraintRight_toRightOf layout_constraintTop_toTopOf layout_constraintTop_toBottomOf layout_constraintBottom_toTopOf layout_constraintBottom_toBottomOf layout_constraintBaseline_toBaselineOf：约束文本基线 layout_constraintStart_toEndOf layout_constraintStart_toStartOf layout_constraintEnd_toStartOf layout_constraintEnd_toEndOf 1234&lt;Button android:id="@+id/buttonA" ... /&gt;&lt;Button android:id="@+id/buttonB" ... app:layout_constraintLeft_toRightOf="@+id/buttonA" /&gt; They all take a reference id to another widget, or the parent (which will reference the parent container, i.e. the ConstraintLayout):12&lt;Button android:id="@+id/buttonB" ... app:layout_constraintLeft_toLeftOf="parent" /&gt; 边距 android:layout_marginStart android:layout_marginEnd android:layout_marginLeft android:layout_marginTop android:layout_marginRight android:layout_marginBottom 注：设置边距时，需要约束控件在ConstraintLayout里的位置。 如果目标View不可见（View.GONE）时，可以通过以下属性设置不同的边距： layout_goneMarginStart layout_goneMarginEnd layout_goneMarginLeft layout_goneMarginTop layout_goneMarginRight layout_goneMarginBottom 居中和偏移居中：1234567&lt;EditText android:id="@+id/edt" ... app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; 偏移（赋值0-1）： layout_constraintHorizontal_bias：水平偏移 layout_constraintVertical_bias：垂直偏移 Circular positioning layout_constraintCircle : references another widget id layout_constraintCircleRadius : 组件间的中心距离 layout_constraintCircleAngle : which angle the widget should be at (in degrees, from 0 to 360) 尺寸约束 指定尺寸大小 wrap_contentandroid:minWidth ：最小宽度android:minHeight ：最小高度android:maxWidth ：最大宽度android:maxHeight ：最大高度app:layout_constrainedWidth=”true|false”app:layout_constrainedHeight=”true|false” 0dp注: MATCH_PARENT is not recommended for widgets contained in a ConstraintLayout. Similar behavior can be defined by using MATCH_CONSTRAINT with the corresponding left/right or top/bottom constraints being set to “parent”. 百分比layout_constraintWidth_min and layout_constraintHeight_min : will set the minimum size for this dimensionlayout_constraintWidth_max and layout_constraintHeight_max : will set the maximum size for this dimensionlayout_constraintWidth_percent and layout_constraintHeight_percent : will set the size of this dimension as a percentage of the parent app:layout_constraintWidth_default=”percent” app:layout_constraintHeight_default=”percent” Ratio比例123456&lt;Button android:layout_width="wrap_content" android:layout_height="0dp" app:layout_constraintDimensionRatio="1:1" /&gt; width:height 链Chain Style：链的第一个控件是这条链的链头，可以在链头中设置layout_constraintHorizontal_chainStyle、layout_constraintVertical_chainStyle CHAIN_SPREAD(default style) Weighted chain CHAIN_SPREAD_INSIDE：展开元素，链的两端贴近parent； CHAIN_PACKED：链的元素将被打包在一起。 GroupGroup将多个控件归为一组，方便隐藏或显示一组控件。 Guideline]]></content>
      <categories>
        <category>android</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-Android Support Library]]></title>
    <url>%2Fandroid-AndroidSupportLibrary%2F</url>
    <content type="text"><![CDATA[概述 Provides a variety of Android feature and utility APIs that are compatible with a wide &gt; range of platform versions.如果在低版本Android平台上开发一个应用程序，而应用程序又想使用高版本才拥有的功能，就需要使用Support库，每一个support library向上兼容于不同的API版本。 官方参考地址：Support Library OverviewFeaturesPackagesSetupRecent Support Library RevisionsSupport Library Revision ArchiveAPI reference：Android Support Library support-v42011年4月发布。添加依赖：12implementation 'com.android.support:support-v4:25.0.0'implementation 'com.android.support:support-fragment:28.0.0' DrawerLayoutFragment1package android.support.v4.app; NestedScrollViewViewPager1package android.support.v4.view; support-fragment1com.android.support:support-fragment:28.0.0-alpha1 FragmentActivity123456java.lang.Object ↳ android.content.Context ↳ android.content.ContextWrapper ↳ android.view.ContextThemeWrapper ↳ android.app.Activity ↳ android.support.v4.app.FragmentActivity FragmentTabHost123456java.lang.Object ↳ android.view.View ↳ android.view.ViewGroup ↳ android.widget.FrameLayout ↳ android.widget.TabHost ↳ android.support.v4.app.FragmentTabHost appcompat-v72014年I/O大会发布。 AppCompatActivity1package android.support.v7.app; 继承结构：java.lang.Object ↳ android.content.Context ↳ android.content.ContextWrapper ↳ android.view.ContextThemeWrapper ↳ android.app.Activity ↳ android.support.v4.app.FragmentActivity ↳ android.support.v7.app.AppCompatActivityAppCompatActivitytheme： cardview-v7gridlayout-v7recyclerview-v7Android 5.0推出。相比ListView优点：1)封装了ViewHolder的回收复用，编写Adapter面向的是ViewHolder而不再是View了，复用的逻辑被封装了，写起来更加简单。2)插拔式的体验，高度的解耦。3)设置布局管理器控制Item的布局方式，横向、竖向、瀑布流方式。4)设置Item间隔样式。继承ItemDecoration。5)控制Item增删的动画，通过ItemAnimator进行绘制。 Design Support LibraryGoogle IO 2015 Material Design支持库。添加依赖：1implementation 'com.android.support:design:25.0.0' AppBarLayout继承LinearLayout，默认方向是Vertical CollapsingToolbarLayoutCoordinatorLayoutCoordinatorLayout遵循Material风格，结合AppBarLayout，CollapsingToolbarLayout等可产生各种炫酷的折叠悬浮效果。 FloatingActionButtonNavigationViewSnackbar页面底部弹出式消息。 TabLayoutTextInputLayoutandroidxandroid 9.0开始，将会使用androidx来替换support库。v7:28.0.0为support库的终结版本。12implementation &apos;androidx.appcompat:appcompat:1.0.2&apos;implementation &apos;androidx.constraintlayout:constraintlayout:1.1.3&apos;]]></content>
      <categories>
        <category>android</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-框架篇-ARouter]]></title>
    <url>%2Fandroid-%E6%A1%86%E6%9E%B6%E7%AF%87-ARouter%2F</url>
    <content type="text"><![CDATA[概览 A framework for assisting in the renovation of Android componentization.帮助Android APP进行组件化改造的路由框架——支持模块间的路由、通信、解耦 GitHub地址：https://github.com/alibaba/ARouter模块：arouter-apiarouter-compilerarouter-register：注册插件进行路由表的自动加载(power by AutoRegister)arouter-idea-plugin：使用IDE插件导航到目标类，Android Studio插件市场中搜索ARouter Helper 背景随着项目的发展，功能模块增多，无法避免面临以下问题： 项目编译时间变长 代码牵一发而动全身，项目维护难度增大 耦合代码与业务造成冲突，极大降低开发效率 组件化应运而生： 使功能模块可以独立开发、编译调试，降低项目编译时间提高开发效率 使功能模块间进行解耦 组件化问题：代码解耦的同时阻断了彼此的通信。Android原生可以实现，但是造成代码耦合，违背组件化目的，有没有简单易管理的通信方案？ARouter应运而生 应用场景 外部URL映射到内部页面，以及参数传递与解析 跨模块页面跳转，模块间解耦 拦截跳转过程，处理登录、埋点等逻辑 跨模块API调用，通过控制反转来做组件解耦 工作原理使用声明拦截器拦截跳转过程，面向切面编程123456789101112131415161718// 比较经典的应用就是在跳转过程中处理登陆事件，这样就不需要在目标页重复做登陆检查// 拦截器会在跳转之间执行，多个拦截器会按优先级顺序依次执行@Interceptor(priority = 8, name = "测试用拦截器")public class TestInterceptor implements IInterceptor &#123; @Override public void process(Postcard postcard, InterceptorCallback callback) &#123; ... callback.onContinue(postcard); // 处理完成，交还控制权 // callback.onInterrupt(new RuntimeException("我觉得有点异常"));// 觉得有问题，中断路由流程 // 以上两种至少需要调用其中一种，否则不会继续路由 &#125; @Override public void init(Context context) &#123; // 拦截器的初始化，会在sdk初始化的时候调用该方法，仅会调用一次 &#125;&#125; 源码解析源码分为arouter-annotation、arouter-api、arouter-compiler三部分 arouter-annotation声名注解： @Autowired @Interceptor @Route 123456789101112131415161718192021222324252627282930@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.CLASS)public @interface Route &#123; /** * Path of route */ String path(); /** * Used to merger routes, the group name MUST BE USE THE COMMON WORDS !!! */ String group() default ""; /** * Name of route, used to generate javadoc. */ String name() default ""; /** * Extra data, can be set by user. * Ps. U should use the integer num sign the switch, by bits. 10001010101010 */ int extras() default Integer.MIN_VALUE; /** * The priority of route. */ int priority() default -1;&#125;]]></content>
      <categories>
        <category>android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>ARouter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-框架篇-RxJava]]></title>
    <url>%2Fandroid-%E6%A1%86%E6%9E%B6%E7%AF%87-RxJava%2F</url>
    <content type="text"><![CDATA[概览 RxJava: Reactive Extensions for the JVM RxJava is a Java VM implementation of Reactive Extensions: a library for composing asynchronous and event-based programs by using observable sequences. It extends the observer pattern to support sequences of data/events and adds operators that allow you to compose sequences together declaratively while abstracting away concerns about things like low-level threading, synchronization, thread-safety and concurrent data structures. GitHub地址：https://github.com/ReactiveX/RxJavamaven central：https://search.maven.org/search?q=io.reactivex.rxjavahttps://search.maven.org/artifact/io.reactivex.rxjava2/rxjava/2.2.8/jar Version 2.xJavadoc：http://reactivex.io/RxJava/2.x/javadoc/ single dependency: Reactive-Streams continued support for Java 6+ &amp; Android 2.3+ performance gains through design changes learned through the 1.x cycle and through Reactive-Streams-Commons research project. Java 8 lambda-friendly API non-opinionated about source of concurrency (threads, pools, event loops, fibers, actors, etc) async or synchronous execution virtual time and schedulers for parameterized concurrency Version 2.x and 1.x will live side-by-side for several years. They will have different group ids (io.reactivex.rxjava2 vs io.reactivex) and namespaces (io.reactivex vs rx).See the differences between version 1.x and 2.x in the wiki article What’s different in 2.0. Learn more about RxJava in general on the Wiki Home. Gradle依赖:1implementation 'io.reactivex.rxjava2:rxjava:2.x.y' Version 1.xJavadoc：http://reactivex.io/RxJava/1.x/javadoc/The 1.x version is end-of-life as of March 31, 2018. No further development, support, maintenance, PRs and updates will happen. The Javadoc of the very last version, 1.3.8, will remain accessible. 工作原理RxJava 2.2.02018年7月31日发布 RxJava 2.1.02017年4月29日发布 RxJava 2.0.02016年10月29日发布，v2.0.0What’s different in 2.0 背压策略RxJava 1.3.8(1.x EOL)2018年3月31日发布RxJava 1.x is now officially end-of-life (EOL). RxJava 1.2.22016年11月3日发布 RxJava 1.0.02014年11月18日发布，v1.0.0VersioningVersion 1.x is now a stable API and will be supported for several years.1io.reactivex:rxjava:1.0.0]]></content>
      <categories>
        <category>android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC-MVP-MVVM-MVI]]></title>
    <url>%2FMVC-MVP-MVVM-MVI%2F</url>
    <content type="text"><![CDATA[小序框架面向于一系列相同行为代码的重用，而设计则面向的是一系列相同结构代码的重用。简而言之：框架是大智慧，用来对软件设计进行分工；设计模式是小技巧，对具体问题提出解决方案，以提高代码复用率，降低耦合度。 对待框架演变的态度：所谓真理只是在特定领域条件下成立的教条理论罢了。 MVCModel-View-Controller（模型-视图-控制器）MVC是一种框架模式而非设计模式，GOF把MVC看作是3种设计模式：观察者模式、策略模式与组合模式的合体，而且其核心在观察者模式，也就是一个基于发布/订阅者模型的框架。 经典MVC1978年由Trygve Reenskaug在Smalltalk-80系统上首次提出。MVC本质是分层解耦，将表现层与逻辑进行分离。 Model：Model可以是一个独立的对象，也可以是一系列对象的集合体。 View：View是Model中一些重要数据在视觉上的体现。 Controller：Controller用于连接User和System，比如当Controller接收到用户的输出时，会将其转换成合适的事件消息，并将该事件消息传递给一个或多个View。 Application Model MVCModel21998年，Model2被首次提出。Model2被应用于Web开发中，将JavaBean、JSP、Servlet对应于MVC的三个部分。Model2改进了事件流向。 User –&gt; Controller –&gt; Model –&gt; Controller –&gt; View –&gt; UserView与Model不再有耦合，接近于MVP，不同的是MVP捕获用户交互请求的是View而不是Controller。 MVPModel-View-Presenter（数据层-UI层-业务逻辑层） MVVMModel-View-ViewModel2005年被微软的WPF和Silverlight的架构师John Gossman提出，并且应用在微软的项目开发中，前身是Martin Fowler在2004年发表的Presentation Model（PM）设计模式。 DataBinding配置12345android &#123; dataBinding &#123; enabled true &#125;&#125; 布局结构首先根节点为layout；其次，布局文件中声名所使用到的数据实体类；然后才是传统布局节点。123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;!--data节点声名数据模型--&gt; &lt;data&gt; &lt;variable name="userModel" type="com.test.demo.testdemo.UserModel" /&gt; &lt;/data&gt; &lt;!--传统布局--&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;Button android:layout_width="match_parent" android:layout_height="50dp" android:text="@&#123;userModel.btnText&#125;" /&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 数据绑定12345678@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); DataBindingTestBinding binding = DataBindingUtil.setContentView(this, R.layout.data_binding_test); UserModel model = new UserModel(); model.setBtnText("中国"); binding.setUserModel(model);&#125; MVIModel-View-Intent（数据层-UI层-业务逻辑层） Model：代表一种状态。]]></content>
      <categories>
        <category>软件架构</category>
      </categories>
      <tags>
        <tag>MVC</tag>
        <tag>MVP</tag>
        <tag>MVVM</tag>
        <tag>MVI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-框架篇-图片加载]]></title>
    <url>%2Fandroid-%E6%A1%86%E6%9E%B6%E7%AF%87-%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[Fresco概览2015年3月Facebook开源的图片框架。https://www.fresco-cn.org/docs/index.html项目地址：https://github.com/facebook/fresco 工作原理源码解析优缺点优点：缺点： 框架大，影响APK大小 使用繁琐 Glide概览2014年Google员工在Picasso基础上进行优化。项目地址：https://github.com/bumptech/glide 工作原理源码解析优缺点Picasso概览2013年2月Square开源的项目。项目地址：https://github.com/square/picasso 工作原理源码解析优缺点Universal-Image-Loader概览2011年9月nostra13开发。项目地址：https://github.com/nostra13/Android-Universal-Image-Loader 工作原理源码解析优缺点]]></content>
      <categories>
        <category>android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-安全篇]]></title>
    <url>%2Fandroid-%E5%AE%89%E5%85%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[混淆反编译加固梆梆加固、爱加密、娜迦、360加固保、腾讯加固、百度加固 常见APP漏洞及风险 静态破解：ApkTool、dex2jar、jd-gui、DDMS、签名工具 二次打包 本地储存数据窃取 界面截取 输入法攻击 协议抓取]]></content>
      <categories>
        <category>android</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-框架篇-异步分发通信]]></title>
    <url>%2Fandroid-%E6%A1%86%E6%9E%B6%E7%AF%87-%E5%BC%82%E6%AD%A5%E5%88%86%E5%8F%91%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[RxJava目前大多数开发者使用EventBus或Otto作为事件总线通信库，对于RxJava使用者来说，RxJava也可以轻松实现事件总线。 EventBusOttoRxAndroidRxBinding]]></content>
      <categories>
        <category>android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web框架]]></title>
    <url>%2FWeb%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[UI框架LayuiLayui MiniUIReactReact AngularAngularJS 诞生于2009年，由Misko Hevery等人创建，之后被Google所收购。 Web.xmlServletServlet通常被称为服务器端小程序，是运行在服务器端的程序，用于处理及响应客户端的请求。Servlet是个特殊的Java类，这个Java类必须继承HttpServlet。每个Servlet可以响应客户端的请求。Servlet提供不同的方法用于响应客户端请求。 doGet doPost doPut doDelete service()：响应客户端的所有请求。 FilterFilter可以认为是Servlet的一种加强版，主要用于对用户请求进行预处理，也可以对HttpServletResponse进行后处理，是个典型的处理链。 Listener]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript-学习篇-基础知识]]></title>
    <url>%2FJavaScript-%E5%AD%A6%E4%B9%A0%E7%AF%87-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[概览 1995年，由Netscape公司的Brendan Eich，在网景导航者浏览器上首次设计实现而成。JavaScript是按ECMAScript规范实现的一种脚本语言，其他的还有JScript、ActionScript。这三种语言还提供了ECMA规范外的额外功能。 完整的JavaScript实现由3个不同部分组成： ECMAScript：核心 文档对象模型（DOM）：是HTML和XML的应用程序接口。DOM将把整个页面规划成由节点层级构成的文档。 浏览器对象模型（BOM） 基础概念： 程序是用Unicode字符集编写的。 区分大小写。 产量是弱类型的。 每行结尾的分号可有可无。 标识符（用来对变量和函数进行命名）必须以字母、下划线、美元符开始。 不区分整数值和浮点数值。所有数字均用浮点数值表示。 字符串是不可变的。 数据类型数据类型分为两类： 原始类型（5种：Number、String、Boolean、null、undefined） 对象类型 ECMAScript没有字符类型，可用双引号或单引号声明字符串。布尔值、数字、字符串的原始值的有趣之处在于它们是伪对象，这意味着它们实际上具有属性和方法。 Number类型ECMAScript默认把具有6个或6个以上前导0的浮点数转换成科学计数法。Number.MAX_VALUENumber.MIN_VALUENaN（Not a Number）表示非数。不能用于算术计算；它与自身不相等。函数isNaN String类型字符串字面量是由双引号或单引号声明的。而Java则是用双引号声明字符串，用单引号声明字符。由于ECMAScript没有字符类型，所以可使用这两种表示法中的任何一种。 类型转换JavaScript可以自由地进行数据类型转换。字符串转换成数字：parseInt()和parseFloat()。强制类型转换 引用类型对象是属性的集合，每个属性都由“名/值对”构成。 Object类 Boolean Number String 变量、常量变量是无类型的，变量可以被赋予任何类型的值，同样一个变量也可以重新赋予不同类型的值。使用var关键字来声明变量。当声明的变量未初始化时，该变量的默认值是undefined。123// 如果未在声名语句中指定变量初始值，默认初始值为undefinedvar i;var i, j; 变量作用域 函数定义是可以嵌套的。 JavaScript使用了函数作用域(function scope)：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。 1234567var scope = "global";function f() &#123; console.log(scope);// 输出“undefined”，而不是“global” var scope = "local";// 变量在这里赋值初始化，但变量本身在函数体内任何地方均是有定义的 console.log(scope);// 输出“local”&#125;f() 全局变量在程序中始终都是有定义的；局部变量在声明它的函数体内以及其所嵌套的函数内始终是有定义的。 运算符与表达式运算符分类： 算术运算符：+、-、*、/、%等 一元操作：++、– 逻辑运算符：!、&amp;&amp;、|| 关系运算符 赋值操作：=、复合赋值（+=、-=、*=、/=） 特殊运算符：delete、instanceof、typeof typeof：检测操作数类型delete：删除属性\=\=\=：判断恒等，无类型转换返回true!==：判断非恒等 语句 条件语句：if/else、switch 循环语句：while、do/while、for、for/in 跳转语句，让解释器跳转至程序的其他部分继续执行，如break、return、throw JavaScript中没有块级作用域，在语句块（花括号括起来的多条语句）中声名的变量并不是语句块私有的。 对象JavaScript除了字符串、数字、true、false、null和undefined之外，其他值都是对象。创建对象的方式： 对象直接量。由若干名/值对组成的映射表，名/值对中间用冒号分隔，之间用逗号分隔，整个映射表用花括号括起来。属性名可以是JavaScript标识符也可以是字符串直接量；属性值可以是任意类型的JavaScript表达式。 12345678910// 没有任何属性的对象var empty = &#123;&#125;; // 两个属性var p = &#123;id: 3, age: 56&#125;;var phone = &#123; "s color": "red", manufacture: &#123; name: "xx" &#125;&#125;; 通过new创建对象。 函数JavaScript里，函数即对象，程序可以随意操控它们。JavaScript的函数可以嵌套在其他函数中定义，这样它们就可以访问它们被定义时所处的作用域中的任何变量。123456// 函数定义两种写法var f = function(x) &#123; return x+1; &#125;function f(x) &#123; return x+1; &#125; 1234567function p(o) &#123; for(var p in o) &#123; console.log(p + ":" + o[p] + "\n"); &#125;&#125;var s = &#123;x:1, y:2&#125;;p(s) 数组console console.log() console.error() console.warn() console.info() 常用浏览器 Chrome Internet Explorer：简称IE。 Firefox Safari Opera 参考 JavaScript权威指南（第6版） JavaScript高级程序设计（第3版） Nicholas C.Zakas 著]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-学习篇-基础知识]]></title>
    <url>%2FCSS-%E5%AD%A6%E4%B9%A0%E7%AF%87-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[简介CSS指层叠样式表 (Cascading Style Sheets)。CSS语法由两个主要的部分构成：选择器（HTML元素），以及一条或多条声明：12345678910/*添加注释*/selector, ...selector5 &#123; property: value; ...&#125; p &#123; color: red; text-align: center;&#125; 标签选择器：A {} id选择器：#name {} 类选择器：.name {} 派生选择器：A B {} .name A {} 或 #name A {} 属性选择器：[属性] {}、[属性=xxx] {}、[属性~=xxx] {} A&gt;B {} 通用选择器：* {} 相邻选择器：A+B {} A~B {} CSS的创建内联样式 &gt; 内部样式 &gt; 外部样式 &gt; 浏览器默认样式外部样式：123&lt;head&gt; &lt;link rel="stylesheet" type="text/css" href="mystyle.css" /&gt;&lt;/head&gt; 内部样式：12345678910111213&lt;head&gt; &lt;style&gt; hr &#123; color: red; &#125; p &#123; margin-left: 10px; &#125; body &#123; background-image: url("images/xxx.gif"); &#125; &lt;/style&gt;&lt;/head&gt; 内联样式：1&lt;p style="color: red;margin-top: 10px"&gt;这是一个段落&lt;/p&gt; 背景（background） 属性 说明 值 版本 background background-attachment background-color background-image background-position background-repeat 文本（text） 属性 说明 值 版本 color 颜色 red、#ff0000、rgb(255,0,0)、inherit CSS1 direction 方向 ltr(默认)、rtl、inherit CSS2 line-height 行高 CSS1 letter-spacing text-align text-decoration 向文本添加修饰 text-indent 缩进元素中文本的首行 text-shadow text-transform unicode-bidi white-space word-spacing 字体（font） 属性 说明 值 版本 font font-family font-size font-size-adjust font-stretch font-style font-variant font-weight 粗细 链接列表（list）表格轮廓（outline）position（定位）overflowfloat（浮动）CSS发展历程CSS32005年12月，W3C开始CSS3标准的制定。 参考https://www.w3school.com.cn/index.html]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML-学习篇-基础知识]]></title>
    <url>%2FHTML-%E5%AD%A6%E4%B9%A0%E7%AF%87-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[基础123&lt;!DOCTYPE html&gt;：声明为HTML5文档。&lt;html&gt;根元素&lt;/html&gt;&lt;body&gt;页面内容&lt;/body&gt; 1234567&lt;!--页面标签--&gt;&lt;h1&gt;-&lt;h6&gt;：HTML标题&lt;p&gt;段落&lt;/p&gt;&lt;br/&gt;：换行&lt;hr/&gt;：水平线&lt;div&gt;组合其他标签的容器&lt;/div&gt; head12345678910111213141516171819202122232425262728293031&lt;head&gt;&lt;!--&lt;meta&gt;标签提供了元数据，元数据不显示在页面上，但会被浏览器解析。--&gt;&lt;meta charset="utf-8"&gt;&lt;meta name="description" content="定义网页描述内容"&gt;&lt;meta name="author" content="定义网页作者"&gt;&lt;!--3秒刷新网页--&gt;&lt;meta http-equiv="refresh" content="3"&gt;&lt;!--为搜索引擎定义关键字--&gt;&lt;meta name="keywords" content="HTML, CSS, XML, XHTML, JavaScript"&gt;&lt;title&gt;网页标题&lt;/title&gt;&lt;!--标题左侧显示logo--&gt;&lt;link rel="shortcut icon" href="图片url"&gt;&lt;!--HTML文档中所有的链接标签的默认链接--&gt;&lt;base href="http://www.test.com/images/" target="_blank"&gt;&lt;!--HTML文档与外部资源之间的关系，通常用于链接到样式表--&gt;&lt;link rel="stylesheet" type="text/css" href="mystyle.css"&gt;&lt;!--HTML文档的样式文件引用地址或自定义样式--&gt;&lt;style type="text/css"&gt;body &#123;background-color:yellow&#125;p &#123;color:green&#125;&lt;/style&gt;&lt;!--加载脚本文件--&gt;&lt;script&gt; ...&lt;/script&gt;&lt;/head&gt; 链接12&lt;!--使用target属性，可以定义链接在哪个窗口显示。_blank表示在新窗口显示--&gt;&lt;a href="http://www.liuweidong.club/" target="_blank"&gt;测试链接&lt;/a&gt; 图片123456789101112&lt;!--html文件与图片在不同盘符--&gt;&lt;img src="file:///f:/*.jpg" width="500" height="300"/&gt;&lt;!--html文件与图片在相同目录--&gt;&lt;img src="*.jpg" width="500" height="300"/&gt; &lt;!--html文件与image文件夹在相同目录--&gt;&lt;img src="image/*.jpg/"width="500" height="300"/&gt;&lt;!--html文件与图片的父文件夹在相同目录--&gt;&lt;img src="../image/*.jpg/"width="500" height="300"/&gt;&lt;!--网络图片--&gt;&lt;img src="http://www.test.com/images/test.png" width="500" height="300"/&gt;&lt;img src="url" alt="图片加载不出来时，替换图片的文本"/&gt; 列表12345678910111213&lt;!--无序列表--&gt;&lt;ul&gt; &lt;li&gt;A&lt;/li&gt; &lt;li&gt;B&lt;/li&gt; &lt;li&gt;C&lt;/li&gt;&lt;/ul&gt;&lt;!--有序列表，start属性可以指定从特定数字开始--&gt;&lt;ol start="3"&gt; &lt;li&gt;A&lt;/li&gt; &lt;li&gt;B&lt;/li&gt; &lt;li&gt;C&lt;/li&gt;&lt;/ol&gt; 格式化123456&lt;b&gt;加粗&lt;/b&gt;&lt;i&gt;斜体&lt;/i&gt;&lt;del&gt;删除&lt;/del&gt;&lt;ins&gt;下划线&lt;/ins&gt;&lt;sub&gt;下标&lt;/sub&gt;&lt;sup&gt;上标&lt;/sup&gt; HTML CSS123456789101112131415161718&lt;!--方式一 内联样式 在HTML元素中使用"style"属性--&gt;&lt;!--background-color：背景色；font-family：字体；color：文字颜色；margin-left：左边距； text-align：文本对齐方式；--&gt;&lt;h2 style="background-color:red;"&gt;标题&lt;/h2&gt;&lt;p style="font-family:arial;color:blue;font-size:20px;margin-left:20px;"&gt;段落&lt;/p&gt;&lt;h1 style="text-align:center;"&gt;居中对齐的标题&lt;/h1&gt;&lt;!--方式二 内部样式--&gt;&lt;head&gt;&lt;style type="text/css"&gt;body &#123;background-color:yellow;&#125;p &#123;color:blue;&#125;&lt;/style&gt;&lt;/head&gt;&lt;!--方式三 外部样式--&gt;&lt;head&gt;&lt;link rel="stylesheet" type="text/css" href="mystyle.css"&gt;&lt;/head&gt; 注意：如果外部样式放在内部样式的后面，则外部样式将覆盖内部样式。 HTML发展历程HTML5（2014/10/28）12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 废弃元素：123456789101112&lt;acronym&gt;&lt;applet&gt;&lt;basefont&gt;&lt;big&gt;&lt;center&gt;&lt;dir&gt;&lt;font&gt;&lt;frame&gt;&lt;frameset&gt;&lt;noframes&gt;&lt;strike&gt;&lt;tt&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-学习篇-View滑动]]></title>
    <url>%2Fandroid-%E5%AD%A6%E4%B9%A0%E7%AF%87-View%E6%BB%91%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[滑动是实现绚丽的自定义控件的基础。 基础知识MotionEvent事件类型 ACTION_DOWN：手指刚接触屏幕 ACTION_MOVE：手指在屏幕上移动 ACTION_UP：手指从屏幕上松开的一瞬间 getX/getY：相对于当前View左上角的坐标getRawX/getRawY：相对于手机屏幕左上角的坐标 TouchSlop系统所能识别的滑动最小距离。常量值，与设备有关。1ViewConfiguration.get(getContext()).getScaledTouchSlop() VelocityTracker速度追踪，手指在滑动过程中的速度（一段时间内手指滑过的像素数）。123456789101112// onTouchEvent方法中使用VelocityTracker velocityTracker = VelocityTracker.obtain();velocityTracker.addMovement(event);// 滑动速度velocityTracker.computeCurrentVelocity(1000);int xVelocity = (int) velocityTracker.getXVelocity();int yVelocity = (int) velocityTracker.getYVelocity();// 重置回收velocityTracker.clear();velocityTracker.recycle(); 滑动冲突]]></content>
      <categories>
        <category>android</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-学习篇-View事件分发机制]]></title>
    <url>%2Fandroid-%E5%AD%A6%E4%B9%A0%E7%AF%87-View%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[点击事件的分发，其实就是对MotionEvent事件的分发过程，产生MotionEvent后，系统需要把这个事件传递给一个具体的View，而这个传递的过程就是分发过程。 事件传递的三个阶段： 分发（Dispatch）：事件分发对应dispatchTouchEvent方法。方法返回值true表示事件被当前视图消费掉，不再继续分发事件；方法返回值是super.dispatchTouchEvent表示继续分发该事件。如果当前视图是ViewGroup及其子类，则会调用onInterceptTouchEvent方法判定是否拦截该事件。 拦截（Intercept）：事件拦截对应onInterceptTouchEvent方法，这个方法只在ViewGroup及其子类中存在，在View和Activity中是不存在的。返回true，不会继续传递给子View，返回false或父类同名方法，则事件会继续传递给子View。 消费（Consume）：事件的消费对应着onTouchEvent。方法返回值true表示当前视图可以处理对应的事件，事件不会向上传递给父视图；返回值为false表示当前视图不处理这个事件，事件会传递给父视图的onTouchEvent方法进行处理。]]></content>
      <categories>
        <category>android</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-学习篇-View工作原理]]></title>
    <url>%2Fandroid-%E5%AD%A6%E4%B9%A0%E7%AF%87-View%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[UI层级Android UI层级如下图： Activity是Android的四大组件之一，与用户交互的窗口。 Window是抽象类，具体实现类是PhoneWindow。Android中的视图都是附加在Window上的，因此Window实际是View的直接管理者，Window和View通过ViewRootImpl来建立联系。Activity中的方法setContentView也是通过Window来完成的。（接口WindowManager继承ViewManager） Activity对象被创建完毕后，会将DecorView添加到Window中，同时会创建ViewRootImpl对象，并将ViewRootImpl对象和DecorView建立关联。 基础知识MeasureSpec32位int值，高2位表示SpecMode测量模式，低30位表示SpecSize某种测量模式下的规格大小。 SpecMode UNSPECIFIED：不指定测量模式。父视图没有限制子视图的大小，子视图可以是想要的任何尺寸。 EXACTLY：精确测量模式。View的测量值就是SpecSize。match_parent AT_MOST：最大值模式。子视图的尺寸可以是不超过父视图允许的最大尺寸的任何尺寸。wrap_content LayoutParamsView绘制流程Measure（测量） [View的测量过程] View的measure（final，子类不能重写该方法）方法进行测量，measure方法会调用View的onMeasure方法。源码如下：123456789101112131415161718192021222324252627282930protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125;/** * Utility to return a default size. Uses the supplied size if the * MeasureSpec imposed no constraints. Will get larger if allowed * by the MeasureSpec. * * @param size Default size for this view * @param measureSpec Constraints imposed by the parent * @return The size this view should be. */public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; [ViewGroup的测量过程] ViewGroup测量完自身后，还会遍历调用所有子View的measure方法。ViewGroup为抽象类，因此没有重写View的onMeasure方法，但是提供了方法measureChildren。源码如下：12345678910111213141516171819202122232425262728293031323334353637383940/** * Ask all of the children of this view to measure themselves, taking into * account both the MeasureSpec requirements for this view and its padding. * We skip children that are in the GONE state The heavy lifting is done in * getChildMeasureSpec. * * @param widthMeasureSpec The width requirements for this view * @param heightMeasureSpec The height requirements for this view */protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125;&#125;/** * Ask one of the children of this view to measure itself, taking into * account both the MeasureSpec requirements for this view and its padding. * The heavy lifting is done in getChildMeasureSpec. * * @param child The child to measure * @param parentWidthMeasureSpec The width requirements for this view * @param parentHeightMeasureSpec The height requirements for this view */protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; 注意：测量完成后，通过getMeasuredWidth与getMeasuredHeight获取宽高。onMeasure方法中可能不准确，在onLayout方法中获取比较靠谱。 Activity中获取View宽高的方式：方法1：view.post(runnable)，将runnable添加到消息队列的末尾，等待Looper调用时，View完成初始化。方法2：Activity中重写方法onWindowFocusChanged。弊端：页面焦点改变时，该方法就会被调用。方法3：ViewTreeObserver - onGlobalLayoutListener，View树的状态发生改变或内部View可见性发生改变时，onGlobalLayout方法将被回调。弊端：onGlobalLayout会被多次调用。方法4：measure(int widthMeasureSpec, int heightMeasureSpec) Layout（布局）Draw（绘制）]]></content>
      <categories>
        <category>android</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP-IP详解]]></title>
    <url>%2FTCP-IP%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[概述互联网地址互联网上的每个接口必须有一个唯一的Internet地址（IP地址，32bit）。 链路层TCP/IP支持多种不同的链路层协议，这取决于网络所使用的硬件，如以太网、令牌环网、FDDI（光纤分布式数据接口）及RS-232串行线路等。 IP（网际协议）Ping程序“ping”源于声呐定位操作。Ping程序由Mike Muuss编写，目的是测试另一台主机是否可达。 UDP（用户数据报协议）引言UDP是一个简单的面向数据报的运输层协议：进程的每个输出操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据报。UDP不提供可靠性。 DNS（域名系统）引言DNS（Domain Name System，域名系统）是一种用于TCP/IP应用程序的分布式数据库，它提供主机名称和IP地址之间的转换及有关电子邮件的选路信息。注意：网络信息中心NIC负责分配顶级域和委派其他指定地区域的授权机构。 基础顶级域名分为三个部分： arpa一个用作地址到名字转换的特殊域。 7个3字符长的普通域。 2个字符的域是基于ISO3166中定义的国家代码，称为国家域。 域 描述 com 商业组织 edu 教育机构 gov 其他美国政府部门 int 国际组织 mil 美国军事网点 net 网络 org 其他组织 报文格式TCP（传输控制协议）TCP提供一种面向连接的、可靠的字节流服务。TCP通过下列方式提供可靠性： 应用数据被分割成TCP认为最适合发送的数据块。 TCP连接的建立与终止TCP超时与重传]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>TCP|IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-组件篇-图表]]></title>
    <url>%2Fandroid-%E7%BB%84%E4%BB%B6%E7%AF%87-%E5%9B%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[MPAndroidChartHelloChartsWilliamChart]]></content>
      <categories>
        <category>android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-源码篇-Handler]]></title>
    <url>%2Fandroid-%E6%BA%90%E7%A0%81%E7%AF%87-Handler%2F</url>
    <content type="text"><![CDATA[背景有时候需要在子线程中进行耗时的I/O操作，读取文件或者访问网络等，当耗时操作完成以后可能需要在UI上做一些改变，由于Android开发规范的限制，不能在子线程中访问UI控件，否则就会触发程序异常，这个时候通过Handler就可以将更新UI的操作切换到主线程中执行。 主要用途 to schedule messages and runnables to be executed as some point in the future; to enqueue an action to be performed on a different thread than your own. 相关类 Looper（消息循环） Message（消息） MessageQueue（存储消息） Handler]]></content>
      <categories>
        <category>android</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-Android Platform]]></title>
    <url>%2Fandroid-AndroidPlatform%2F</url>
    <content type="text"><![CDATA[android.animationAnimatorAnimatorSetValueAnimatorandroid.appActivityApplicationDatePickerDialogDialogandroid.bluetoothandroid.contentContextContextWrapperIntentandroid.databaseandroid.graphicsBitmapandroid.utilSparseArrayAndroid内部特有的API。用来替代HashMap&lt;Integer, E&gt;这种形式，使用SparseArray更加节省内存空间。HashMap是数组和链表的结合体，被称为链表散列。SparseArray是单纯数组的结合，被称为稀疏数组。Android堆区允许使用的最大内存仅仅16M。 android.viewViewViewGroupWindowandroid.webkitWebViewandroid.widgetEditTextFrameLayoutGridViewImageViewListViewTabHost12345java.lang.Object ↳ android.view.View ↳ android.view.ViewGroup ↳ android.widget.FrameLayout ↳ android.widget.TabHost TextViewToolbar]]></content>
      <categories>
        <category>android</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[版本控制]]></title>
    <url>%2F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[工欲善其事，必先利其器。——《论语·卫灵公》 版本控制系统（VCS）版本控制系统（Version Control System），是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 本地版本控制系统集中化的版本控制系统（CVCS）如CVS、Subversion、Perforce等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 分布式版本控制系统分布式版本控制系统（Distributed Version Control System，DVCS），如Git、Mercurial、Bazaar、Darcs等，客户端并不只是提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 CVSCVS（Concurrent Versions System）并发版本系统。 Subversion简介2000年，CollabNet开始寻找CVS替代产品的开发人员。Subversion（SVN）是一个自由开源的版本控制系统，相对于CVS，采用了分支管理系统，设计目标就是取代CVS。SVN是一种集中式文件版本管理系统。文件的版本信息都存放在服务器上。 TortoiseSVNTortoiseSVN是Subversion版本控制系统的一个免费开源客户端，可以超越时间的管理文件和目录。 BitKeeperBitKeeper允许真正的分布式开发，每个人都拥有自己的主副本 master copy。 Git简介分布式与集中式的区别： 开发者可以本地提交，每个开发者机器上都有一个服务数据库。 分布式版本控制系统 Workspace：工作区 Index/Stage：暂存区 Repository：仓库区（本地仓库） Remote：（远程仓库） Git命令【git config –global user.name “用户名”】设置用户名【git config –global user.email “邮箱”】设置邮箱【git init】在当前目录新建一个Git代码库【git init [project-name]】【git clone url】下载一个项目和整个代码历史【git branch】列出所有本地分支【git branch -r】列出所有远程分支【git status】显示有变更的文件【git log】显示当前分支的版本历史【git pull [remote] [branch]】取回远程仓库的变化，并与本地分支合并【git pull origin master –allow-unrelated-histories】【git commit 】【git push [remote] [branch]】上传本地分支到远程仓库【git push [remote] -force】强行推送当前分支到远程仓库，即使有冲突 可视化界面软件SourceTree拥有可视化界面的项目版本控制软件，适用于git项目管理。分支共有5种类型： master：最终发布版本，整个项目中有且只有一个 develop：项目的开发分支，原则上项目中有且只有一个 feature：功能分支，用于开发一个新的功能 release：预发布版本，介于master与develop之间的版本，主要用于测试 hotfix：修复补丁，用于修复master上的bug，直接作用于master 在线代码仓库GitHubGitHub是在线的基于Git的代码托管服务。GitHub是2008年由Ruby on Rails编写而成。克隆方式： HTTPS：每次都需要登录验证。git clone https://github.com/用户名/***.git SSH：一次验证即可。git clone git@github.com:用户名/***.git SSH： 【cd ~/.ssh】查询本地是否存在ssh密钥 【ssh-keygen -t rsa -C “邮箱”】生成ssh密钥对。执行命令后，按3次回车，密码一般为空即可。在C盘用户目录下会生成一个.ssh的文件夹，里面包含id_rsa和id_rsa.pub两个文件。 添加公钥到GitHub账户。New SSH Key，填写SSH Keys的名称和本地公钥文件id_rsa.pub的内容。 【ssh -T git@github.com】测试密钥，连接GitHub。 Android Studio本地项目上传到GitHub： VCS—&gt;Enable Version Control Integration，会生成更新和提交两个按钮。 在Android Studio内部配置Git和GitHub账号 VCS—&gt;Import into Version Control—&gt;Share Project on GitHub GitLabGitLab是利用Ruby on Rails开源的版本管理系统，实现一个自托管的Git项目仓库，可通过Web界面进行访问公开的或私人项目。依赖组件：Ruby 1.9.3+，MySQL，Git，Redis，sidekiq BitbucketGitEEMercurialMercurial是一种轻量级分布式版本控制系统，采用Python语言实现，易于学习和使用，扩展性强。基于GNU General Public License（GPL）授权的开源项目。]]></content>
      <categories>
        <category>软件开发工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符集与编码]]></title>
    <url>%2F%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[ASCII1961年提出基本的ASCII字符集共有128个字符，其中有96个可打印字符，包括常用的字母、数字、标点符号等，另外还有32个控制字符。 Bin——Dec——Hex——缩写/字符——解释00000000——0——00——NUL（null）——空字符00100000——32——20——（space）——空格00100001——33——21——!00110000——48——30——001000000——64——40——@01000001——65——41——A01100001——97——61——a01111111——127——7F——DEL (delete)——删除 ASCII大致可以分作三部分组成。第一部分是：ASCII码非打印控制字符ASCII码表上的数字0–31分配给了控制字符，用于控制像打印机等一些外围设备。例如，12代表换页/新页功能。此命令指示打印机跳到下一页的开头。第二部分是：ASCII码打印字符数字32–126分配给了能在键盘上找到的字符，当您查看或打印文档时就会出现。数字127代表 DELETE 命令。第三部分是：扩展ASCII码打印字符扩展的ASCII字符满足了对更多字符的需求。扩展的ASCII包含ASCII中已有的128个字符（数字0–32显示在下图中），又增加了128个字符，总共是256个。即使有了这些更多的字符，许多语言还是包含无法压缩到256个字符中的符号。因此，出现了一些ASCII码的变体来囊括地区性字符和符号。例如，许多软件程序把ASCII码表（又称作ISO8859-1）用于北美、西欧、澳大利亚和非洲的语言。 Unicode1990年开始研发，1994年正式公布。 UTF-8GB2312GBK]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入理解计算机系统]]></title>
    <url>%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[计算机硬件输入单元、输出单元、CPU内部的控制单元、算术逻辑单元、内存 总线：贯穿整个系统的是一组电子管道，称作总线，携带信息字节并负责在各个部件间传递。 I/O设备：用户输入的键盘和鼠标，用户输出的显示器，以及用于长期存储数据和程序的磁盘驱动器（磁盘）。每个I/O设备都通过一个控制器或适配器与I/O总线相连。控制器和适配器之间的区别主要是它们的封装方式。 主存：主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存取存储器（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引）。 CPU，简称处理器，是解释（或执行）存储在主存中指令的引擎。运算器：运算器又称算术逻辑单元（ALU，Arithmetic Logic Unit）。 数字计算机的整个历史中，有两个需求是驱动进步的持续动力：一个是我们想要计算机做得更多，另一个是我们想要计算机运行得更快。 CPU（中央处理单元）解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC）。精简指令集（RISC）与复杂指令集（CISC）系统。CPU的“外频”与“倍频”：外频指的是CPU与外部组件进行数据传输/运算时的速度，倍频是CPU内部用来加速工作性能的一个倍数，两者相乘才是CPU的频率。主板芯片组分为北桥与南桥，北桥的总线称为系统总线，因为是内存传输的主要通道，所以速度较快；南桥是所谓的输入输出（I/O）总线，主要用于“联系”硬盘、USB、网卡等接口设备。 内存主存：一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存取存储器（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址。 DRAM（动态随机访问内存），随机访问内存只有在通电时才能记录与使用，断电后数据就消失了。（也称挥发性内存） SRAM（静态随机访问内存）CPU内部第二层高速缓存。 ROM非挥发性内存。 硬盘与存储设备硬盘：机械手臂、磁头、盘片、主轴马达传输接口：IDE接口、SATA接口、SCSI接口缓冲存储器盘片分出扇区（Sector）和柱面（Cylinder）两种单位。扇区每个512bytes磁盘的第一个扇区记录两个重要信息：主引导分区（Master Boot Record，MBR）446bytes和分区表（partition table）64bytes 主板CMOS：记录主板上面的重要参数BIOS：写入到主板上某一块闪存或EEPROM的程序，开机执行，加载CMOS当中的参数，并尝试调用存储设备中的开机程序，进一步进入到操作系统。BIOS程序也可以修改CMOS中的数据。 操作系统操作系统内核（Kernel）直接参考硬件规格写成。系统调用（System Call）内核功能： 系统调用接口 程序管理：CPU调度机制 内存管理 文件系统管理：I/O 设备驱动]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL详解]]></title>
    <url>%2FMySQL%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[概览MySQLMySQL的体系结构：采用客户/服务器体系结构。因此，在使用MySQL的时候，实际上在使用两个程序。一个是服务器程序，指的是mysqld，运行在存放你数据库的机器上。另一个是客户程序，负责连接到数据库服务器。优点：并发控制由服务器提供，因而不会出现两个用户同时修改同一条记录的现象。 安装与使用 msi安装或zip解压缩 https://dev.mysql.com/downloads/mysql/ 配置环境变量 MYSQL_HOME（D:\swTools\mysql-8.0.15-winx64） Path（;%MYSQL_HOME%\bin） 在目录mysql-8.0.15-winx64\bin中新建文件my.ini参考，内容如下所示： 12345678910111213141516[mysql]# 设置mysql客户端默认字符集default-character-set=utf8 [mysqld]#设置3306端口port = 3306 # 设置mysql的安装目录basedir=D:\swTools\mysql-8.0.15-winx64# 设置mysql数据库的数据的存放目录datadir=D:\swTools\mysql-8.0.15-winx64\data# 允许最大连接数max_connections=200# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB 安装MySQL：以管理员身份运行cmd， 切换到目录cd D:\swTools\mysql-8.0.15-winx64\bin 中，输入 1mysqld -install 初始化：执行命令后会在MySQL的安装目录下生成data目录并创建root用户。 1mysqld --initialize-insecure --user=mysql 启动服务 1net start mysql 停止服务 1net stop mysql 12Host：localhostPort：3306 命令【mysqld -install】安装MySQL【mysqld –initialize-insecure –user=mysql】初始化：执行命令后会在MySQL的安装目录下生成data目录并创建root用户。【net start mysql】启动服务【net stop mysql】停止服务【mysql -u root -p】登录mysql【mysql -hxx -uxx -pxx】进入mysql数据库。-h表示服务器名，-u数据库用户名，-p为密码【show databases;】显示数据库列表【mysqladmin -u用户名 -p旧密码 password 新密码】修改密码【exit】退出mysql数据库 管理工具SQLyogSQLyog是一个快速而简洁的图形化管理MySQL数据库的工具，它能够在任何地点有效地管理你的数据库，由业界著名的Webyog公司出品。 FAQ SQLyog连接数据库报错plugin caching_sha2_password could not be loaded12345678910# 登录MySQLmysql -uroot -p # 修改加密规则ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;password&apos; PASSWORD EXPIRE NEVER; # 更新一下用户的密码 ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;password&apos;; # 刷新权限FLUSH PRIVILEGES; # 重置密码alter user &apos;root&apos;@&apos;localhost&apos; identified by &apos;***123456&apos;; NavicatNavicat是一套快速、可靠并价格相当便宜的数据库管理工具，专为简化数据库的管理及降低系统管理成本而设。下载地址：http://www.formysql.com/xiazai.html]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库详解]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[[关系型数据库]关系型数据库管理系统（Relational Database Management System，RDBMS） OracleORACLE数据库系统是美国ORACLE公司（甲骨文）提供的以分布式数据库为核心的一组软件产品，是目前最流行的客户/服务器(CLIENT/SERVER)或B/S体系结构的数据库之一。 MySQLMariaDBMariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可 MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。 SQL ServerSQL Server是Microsoft公司推出的关系型数据库管理系统。 AccessMicrosoft Office Access是微软把数据库引擎的图形用户界面和软件开发工具结合在一起的一个数据库管理系统。它是微软office的一个成员, 在包括专业版和更高版本的office版本里面被单独出售。 DB2IBM公司开发的一套关系型数据库管理系统，它主要的运行环境为UNIX（包括IBM自家的AIX）、Linux、IBM i（旧称OS/400）、z/OS，以及Windows服务器版本。 [非关系型数据库]NoSQLNoSQL（Not Only SQL）]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQL语句]]></title>
    <url>%2FSQL%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[概览SQL（Structured Query Language，结构化查询语言），分类如下： DDL：CREATE、ALTER、DROP DML：INSERT、UPDATE、DELETE DCL：定义访问权限和安全级别 DQL：数据查询语言，用来查询记录。SELECT DDL123456789101112131415【操作数据库】// 创建数据库create database test;create database test character set gbk;show create database test;// 修改数据库字符集alter database test character set utf8;// 删除数据库drop database test;select database();// 切换数据库use test; 123456789101112131415161718192021222324252627282930【操作数据表】// 创建表create table people( id int, name varchar(5), birthday date, remark text );// 查看表格的创建细节show create table 表名;// 显示所有表show tables;// 查看表信息desc 表名;alter table 表名 character set gbk;// 增加一列alter table 表名 add 列名 类型;// 修改列的长度alter table 表名 modify 列名 类型(长度);// 删除列alter table 表名 drop 列名;// 修改列名alter table 表名 change 列1 列2 类型(长度);// 修改表名rename table 表名1 to 表名2;// 删除表drop table 表名; DML123456【插入操作】insert into user (id,num,birthday,remark) values (2,'mi','2019-07-23','你好，mi'),(3,'ali','2019-07-23','你好，ali'),(4,'bd','2019-07-23','你好，bd'); 123456【修改操作】// 修改多列数据逗号隔开// 更新表中所有该列对应的数据update 表名 set 列名='2019-07-24';// 更新指定数据update 表名 set 列名='2019-07-25' where 列名='lwd'; 123456【删除操作】delete from 表名 where 列名='';// 删除表中所有记录（表结构还在）delete from 表名;// 删除表truncate table 表名; DQL123select 列名from 表名where 行条件]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-框架篇-日志打印]]></title>
    <url>%2Fandroid-%E6%A1%86%E6%9E%B6%E7%AF%87-%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%2F</url>
    <content type="text"><![CDATA[Logger概览工作原理源码解析]]></content>
      <categories>
        <category>android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建工具-Gradle]]></title>
    <url>%2F%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7-Gradle%2F</url>
    <content type="text"><![CDATA[概览Gradle2013年5月，谷歌发布Android Studio（基于JetBrains的IntelliJ IDEA），并对Gradle进行了支持。Gradle构建脚本的书写没有基于传统的XML文件，而是基于Groovy的领域专用语言（DSL）。 Gradle构建Android项目时，需要创建一个构建脚本，通常称为build.gradle。 Gradle有约定优于配置的原则，即为设置和属性提供默认值。 You can specify the Gradle version in either the File &gt; Project Structure &gt; Project menu in Android Studio, or by editing the Gradle distribution reference in the gradle/wrapper/gradle-wrapper.properties file.123...distributionUrl = https\://services.gradle.org/distributions/gradle-5.1.1-all.zip... GroovyGroovyGroovy是一种适用于Java虚拟机的动态语言。 类和成员变量def：声名变量 方法在Groovy中，方法的最后一行通常默认返回，即使没有使用return关键字。 ClosuresClosures是匿名代码块，可以接受参数和返回值。 集合List和Map123456List list = [1, 2, 3, 4]list.each() &#123; element -&gt; println element&#125;Map prices = [apple:10, car:100] 123apply plugin: 'com.android.application'// apply()是Project类的一个方法。参数是key为plugin，value为com.android.application的Map。project.apply([plugin: 'com.android.application']) 项目和任务每一次构建都包括至少一个项目，每一个项目又包括一个或多个任务。每个build.gradle文件都代表着一个项目，任务定义在构建脚本里。当初始化构建过程时，Gradle会基于build文件组装项目和任务对象。一个任务对象包含一系列动作对象，这些动作对象之后会按顺序执行。一个单独的动作对象就是一个待执行的代码块，它和Java中的方法类似。构建生命周期 初始化 配置 执行 Gradle Wrapper项目根目录，在terminal上运行gradlew -v或在命令行上运行gradlew.bat -v检查项目中的Gradle Wrapper是否可用。https://gradle.org/releases/ gradle文件 settings.gradle：位于项目的根目录 1include ':app' build.gradle：顶级构建文件，位于项目的根目录 1234567891011121314151617buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; // Gradle的Android插件 classpath 'com.android.tools.build:gradle:2.3.0' &#125;&#125;allprojects &#123; repositories &#123; jcenter() google() &#125;&#125; build.gradle：模块级构建文件，位于Module的根目录，可以覆盖顶层build.gradle中的任何属性。 12345678910111213141516171819202122232425262728293031323334353637android &#123; compileSdkVersion 27 buildToolsVersion '27.0.3' defaultConfig &#123; applicationId "com.test" minSdkVersion 14 targetSdkVersion 27 versionCode 1 versionName "1.0.0" &#125; signingConfigs &#123; debug &#123; storeFile file("./doc/debug/debug.keystore") storePassword "android" keyAlias "androiddebugkey" keyPassword "android" &#125; &#125; buildTypes &#123; debug &#123; minifyEnabled false signingConfig signingConfigs.debug &#125; release &#123; minifyEnabled true signingConfig signingConfigs.debug proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125;dependencies &#123;&#125; applicationId：定义在manifest文件中的package，继续用在你的源代码和R类中，而之前被用作设备和Google Play唯一标识的package name，现在则被称之为applicationId。ext：Gradle允许在Project对象上添加额外属性。这意味着任何build.gradle文件都能定义额外的属性，添加额外属性需要通过ext代码块。顶层构建文件添加如下代码块：1234ext &#123; compileSdkVersion = 23 buildToolsVersion = '23.0.3'&#125; 模块层的构建文件使用rootProject获取属性：1234android &#123; compileSdkVersion rootProject.ext.compileSdkVersion buildToolsVersion rootProject.ext.buildToolsVersion&#125; BuildConfigSDK工具版本升级到17之后，构建工具都会生成一个叫作BuildConfig的类，该类包含一个按照构建类型设置值得DEBUG常量。1234567891011android &#123; buildTypes &#123; debug &#123; buildConfigField "boolean","IS_LOG","true" buildConfigField "String","URL","\"http://test.example.com\"" &#125; release &#123; buildConfigField "boolean","IS_LOG","false" &#125; &#125;&#125; 字符串值必须用转义双引号括起来，这样才会生成实际意义上的字符串。Java代码中可以这样用BuildConfig.IS_LOG和BuildConfig.URL buildConfigField resValue 依赖管理本地依赖https://developer.android.google.cn/studio/build/dependencies.html12345678910111213141516dependencies &#123; // 依赖单个JAR文件 compile files('libs/test.jar') // 依赖所有文件 compile fileTree('libs') // 依赖指定文件格式，如JAR compile fileTree(dir: 'libs', include: ['*.jar']) // 远程依赖 implementation 'com.example.android:app-magic:12.3' // 本地库模块依赖项 implementation project(':mylibrary')&#125; 原生依赖库.so文件：在模块的main目录下新建jniLibs文件夹，然后为每个平台（armeabi、mips、x86）创建子文件夹。如果此约定不生效，可以在构建文件中设置相关设置：12345android &#123; sourceSets.main &#123; jniLibs.srcDir 'src/main/libs' &#125;&#125; .aar文件： 添加依赖仓库文件夹 添加依赖，如下 123dependencies &#123; compile(name: 'aarName', ext: 'aar')&#125; 语义化版本将依赖添加到JCenter等依赖仓库时，约定遵循了一套版本化规则，称为语义化版本。版本数字的格式一般为major.minor.patch 当做不兼容的API变化时，major版本增加。 当以向后兼容的方式添加功能时，minor版本增加。 当修复一些bug时，patch版本增加。 基于以上规则，可以添加动态化版本。+ 远程仓库如果您的依赖项并非本地库或文件树，Gradle会在您的build.gradle文件repositories程序块中指定的任何一个在线代码库中寻找文件。列出各代码库的顺序决定了Gradle在这些代码库中搜索各项目依赖项的顺序。默认情况下，Android Studio新项目会在项目的顶级build.gradle文件中指定Google的Maven代码库和 JCenter作为代码库位置，如下所示：123456allprojects &#123; repositories &#123; google() jcenter() &#125;&#125; 如果您需要的内容来自Maven中央代码库，则添加mavenCentral()如果来自本地代码库，则使用 mavenLocal()12345678allprojects &#123; repositories &#123; google() jcenter() mavenCentral() mavenLocal() &#125;&#125; 或者，也可像下面这样声明特定Maven或Ivy代码库：123456789101112131415allprojects &#123; repositories &#123; maven &#123; url "https://repo.example.com/maven2" &#125; maven &#123; url "file://local/repo/" &#125; ivy &#123; url "https://repo.example.com/ivy" &#125; &#125;&#125; 本地仓库通过使用flatDirs添加一个常用文件夹作为仓库。12345repositories &#123; flatDir &#123; dirs 'libs', '../Framework/libs' &#125;&#125; 构建varianthttps://developer.android.google.cn/studio/build/build-variants.html 构建类型https://developer.android.google.cn/studio/build/build-variants.html#build-types12345678910111213141516171819android &#123; buildTypes &#123; debug &#123; &#125; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; // 用已有的构建类型属性初始化新的构建类型 staging.initWith(buildTypes.debug) staging &#123; applicationIdSuffix ".staging" versionNameSuffix "-staging" &#125; &#125;&#125; 可以根据构建类型来添加依赖。如debugCompile ‘com.android.support:***:1.0.0’ product flavorhttps://developer.android.google.cn/studio/build/build-variants.html#product-flavors1234567891011android &#123; productFlavors &#123; free &#123; &#125; paid &#123; &#125; &#125;&#125; 签名配置应用签名123456789101112android &#123; signingConfigs &#123; staging.initWith(signingConfigs.debug) release &#123; storeFile file("../key/debug.keystore") storePassword "android" keyAlias "androiddebugkey" keyPassword "android" &#125; &#125;&#125; 加速构建Jack和JillJack（Java Android Compiler Kit）是一个新的Android构建工具链，其可以直接编译Java源码为Android Dalvik的可执行格式。它有自己的.jack依赖库格式，也采用了打包和缩减。Jill（Jack Intermediate Library Linker）是一个可以将.aar和.jar文件转换成.jack依赖库的工具。useJack = true]]></content>
      <categories>
        <category>软件开发工具</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建工具-Maven]]></title>
    <url>%2F%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7-Maven%2F</url>
    <content type="text"><![CDATA[概览Home Page: https://maven.apache.org/Source Code: https://gitbox.apache.org/repos/asf/maven.gitIssue Tracking: https://issues.apache.org/jira/browse/MNGhttps://maven.apache.org/plugins/Maven仓库：https://mvnrepository.com/ 构建工具发展史：Make -&gt; Ant -&gt; Maven -&gt; Gradle Eclipse + Ant 组合的时候，引入库都是下载jar包或aar包放到lib目录下，然后添加引用。!!!不能实时更新。 Android Studio + Gradle 组合中gradle中提供了可以从远端拉取jar包和aar包引入本地。 Maven仓库分为两类：本地仓库和远程仓库。 本地仓库就是本地存放jar包的位置，Maven的本地仓库在最开始的时候并不会创建，而是第一次启动Maven时，在当前用户的文件夹下建立一个.m2文件，其中存放Maven本地仓库的所有jar包。 远程仓库又分为：中央仓库、Nexus私服和其他公共仓库。 安装与配置https://maven.apache.org/download.html配置环境变量： MAVEN_HOME——安装路径 PATH——%MAVEN_HOME%\bin; 【mvn -v】命令行输入，查看配置是否成功。 配置Maven： 打开maven的安装目录，找到文件\conf\settings.xml 标签localRepository，配置本地仓库存储路径。 标签mirror，配置Maven镜像。 123456&lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: $&#123;user.home&#125;/.m2/repository --&gt;&lt;localRepository&gt;E:\mavenRepository&lt;/localRepository&gt; Maven镜像：https://maven.aliyun.com/123456789101112&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt; &lt;id&gt;repo2&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;repo2 maven&lt;/name&gt; &lt;url&gt;http://repo2.maven.org/maven2&lt;/url&gt;&lt;/mirror&gt; POM概览http://maven.apache.org/pom.htmlPOM stands for “Project Object Model”.It is an XML representation of a Maven project held in a file named pom.xml.1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;!--当前仅有的可以被Maven 2 &amp; 3同时支持的POM版本--&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- The Basics --&gt; &lt;groupId&gt;...&lt;/groupId&gt; &lt;artifactId&gt;...&lt;/artifactId&gt; &lt;version&gt;...&lt;/version&gt; &lt;!--The current core packaging values are: pom, jar, maven-plugin, ejb, war, ear, rar.--&gt; &lt;packaging&gt;...&lt;/packaging&gt; &lt;dependencies&gt;...&lt;/dependencies&gt; &lt;parent&gt;...&lt;/parent&gt; &lt;dependencyManagement&gt;...&lt;/dependencyManagement&gt; &lt;modules&gt;...&lt;/modules&gt; &lt;properties&gt;...&lt;/properties&gt; &lt;!-- Build Settings --&gt; &lt;build&gt;...&lt;/build&gt; &lt;reporting&gt;...&lt;/reporting&gt; &lt;!-- More Project Information --&gt; &lt;name&gt;...&lt;/name&gt; &lt;description&gt;...&lt;/description&gt; &lt;url&gt;...&lt;/url&gt; &lt;inceptionYear&gt;...&lt;/inceptionYear&gt; &lt;licenses&gt;...&lt;/licenses&gt; &lt;organization&gt;...&lt;/organization&gt; &lt;developers&gt;...&lt;/developers&gt; &lt;contributors&gt;...&lt;/contributors&gt; &lt;!-- Environment Settings --&gt; &lt;issueManagement&gt;...&lt;/issueManagement&gt; &lt;ciManagement&gt;...&lt;/ciManagement&gt; &lt;mailingLists&gt;...&lt;/mailingLists&gt; &lt;scm&gt;...&lt;/scm&gt; &lt;prerequisites&gt;...&lt;/prerequisites&gt; &lt;repositories&gt;...&lt;/repositories&gt; &lt;pluginRepositories&gt;...&lt;/pluginRepositories&gt; &lt;distributionManagement&gt;...&lt;/distributionManagement&gt; &lt;profiles&gt;...&lt;/profiles&gt;&lt;/project&gt; 1234567891011121314151617&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.maven&lt;/groupId&gt; &lt;artifactId&gt;maven-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; ...&lt;/dependencies&gt; The Super POMMaven有一个超级pom，所有的pom文件均继承此文件。路径：lib\maven-model-builder-3.5.4.jar\org\apache\maven\model\pom-4.0.0.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!--Licensed to the Apache Software Foundation (ASF) under oneor more contributor license agreements. See the NOTICE filedistributed with this work for additional informationregarding copyright ownership. The ASF licenses this fileto you under the Apache License, Version 2.0 (the"License"); you may not use this file except in compliancewith the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing,software distributed under the License is distributed on an"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANYKIND, either express or implied. See the License for thespecific language governing permissions and limitationsunder the License.--&gt;&lt;!-- START SNIPPET: superpom --&gt;&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Central Repository&lt;/name&gt; &lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Central Repository&lt;/name&gt; &lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;releases&gt; &lt;updatePolicy&gt;never&lt;/updatePolicy&gt; &lt;/releases&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;build&gt; &lt;directory&gt;$&#123;project.basedir&#125;/target&lt;/directory&gt; &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/classes&lt;/outputDirectory&gt; &lt;finalName&gt;$&#123;project.artifactId&#125;-$&#123;project.version&#125;&lt;/finalName&gt; &lt;testOutputDirectory&gt;$&#123;project.build.directory&#125;/test-classes&lt;/testOutputDirectory&gt; &lt;sourceDirectory&gt;$&#123;project.basedir&#125;/src/main/java&lt;/sourceDirectory&gt; &lt;scriptSourceDirectory&gt;$&#123;project.basedir&#125;/src/main/scripts&lt;/scriptSourceDirectory&gt; &lt;testSourceDirectory&gt;$&#123;project.basedir&#125;/src/test/java&lt;/testSourceDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;$&#123;project.basedir&#125;/src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;testResources&gt; &lt;testResource&gt; &lt;directory&gt;$&#123;project.basedir&#125;/src/test/resources&lt;/directory&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;pluginManagement&gt; &lt;!-- NOTE: These plugins will be removed from future versions of the super POM --&gt; &lt;!-- They are kept for the moment as they are very unlikely to conflict with lifecycle mappings (MNG-4453) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;2.2-beta-5&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;version&gt;2.8&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.3&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; &lt;reporting&gt; &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/site&lt;/outputDirectory&gt; &lt;/reporting&gt; &lt;profiles&gt; &lt;!-- NOTE: The release profile will be removed from future versions of the super POM --&gt; &lt;profile&gt; &lt;id&gt;release-profile&lt;/id&gt; &lt;activation&gt; &lt;property&gt; &lt;name&gt;performRelease&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;/activation&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;inherited&gt;true&lt;/inherited&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;attach-sources&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;jar-no-fork&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;inherited&gt;true&lt;/inherited&gt; &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;attach-javadocs&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;inherited&gt;true&lt;/inherited&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;updateReleaseInfo&gt;true&lt;/updateReleaseInfo&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/profile&gt; &lt;/profiles&gt;&lt;/project&gt;&lt;!-- END SNIPPET: superpom --&gt; Maven服务源 JCenter托管在Bintray上面的Maven仓库。 Maven Central托管在Sonatype上面的Maven仓库。 JitPack JCenter优点: 基于CDN分布函数库，JCenter提供了更快的下载速度。 JCenter是最大的Java仓库，可以说Maven Central是JCenter的一个子集，托管在Maven Central中的函数库，几乎都托管在JCenter上面。 上传简单，Bintray的用户界面对用户友好。 获取函数库的原理完整的函数库依赖字符串包含三部分：GROUP_ID:ARTIFACT_ID:VERSIONGradle根据依赖配置，向Maven Repository服务器查询是否存在该版本的函数库，如果存在，则会根据服务器类型拼接下载请求url。 JCenter：http://jcenter.bintray.com/... Maven Central：https://oss.sonatype.org/content/repositories/releases... Maven私服私服是架设在局域网内的远程仓库，目的是代理远程仓库及部署第三方构件。优点： 节省外网带宽：减少大量对远程仓库的重复请求 加速maven构建 部署第三方构件：构件无法从远程仓库获取，如公司内部生成的私有构件。 Sonatype Nexus https://www.sonatype.com/download-oss-sonatype 自定义参数etc\nexus-default.properties 启动nexus 默认端口：8081http://127.0.0.1:8081/http://localhost:8081/默认配置文件：C:\swTools\nexus-3.13.0-01\etc\nexus-default.properties默认登录：admin/admin123 常用命令：【nexus.exe/install】安装nexus为系统服务【nexus.exe/uninstall】卸载nexus为系统服务【nexus.exe/start】启动nexus服务【nexus.exe/stop】停止nexus服务【nexus.exe/run】启动服务 Apache ArchivaJFrog Artifactory历史版本https://maven.apache.org/docs/history.html]]></content>
      <categories>
        <category>软件开发工具</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统-Windows]]></title>
    <url>%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Windows%2F</url>
    <content type="text"><![CDATA[运行【calc】计算器【charmap】启动字符映射表【cleanmgr】打开磁盘清理工具【cmd】命令提示符【compmgmt.msc】计算机管理【explorer】打开资源管理器【mspaint】打开画图板【mstsc】远程桌面连接【notepad】打开记事【osk】打开屏幕键盘【regedit】注册表【services.msc】服务【winver】Windows版本【slmgr.vbs -dlv】查询win10激活信息【slmgr.vbs -dli】查询操作系统版本、许可证状态【slmgr.vbs -xpr】查询win10是否永久激活 cmd【cd\】切换到根目录【cd..】返回上级目录【cd 路径】打开指定目录【dir】查看目录【x:】切换盘符【md 文件夹名称】创建目录【rd 路径】删除当前指定的目录【echo a&gt;xxx.txt】创建文件【echo %JAVA_HOME%】查看路径 【net start】查看开启了哪些服务【net start 服务名】开启服务。如：net start mysql【net stop 服务名】停止服务。如：net stop mysql【netstat -ano|findstr 端口号】查看端口【net share】查看共享的文件【path】查看环境变量【services.msc】系统服务 【tree /f &gt; list.txt】生成目录结构树 快捷键【F2】重命名【F11】最大化/最小化活动窗口【Windows键/Ctrl+Esc】打开开始菜单【Windows键+M】最小化所有被打开的窗口【Windows键+R】打开“运行”对话框【Windows键+Break】打开“系统属性”对话框【Windows键+D】最小化/还原所有窗口【Windows键+L】锁定计算机【Windows键+E】打开资源管理器【Delete】放入回收站【Shift+Delete】彻底删除【Alt+1】标准型模式【Alt+2】科学型模式【Alt+3】切换到程序员模式【Alt+F4 】关闭当前应用程序 【Alt+Tab】切换应用程序 【Alt+D】选中地址栏【Ctrl+Shift+N】新建文件夹【Ctrl+Shift+&gt;】增大字体大小【Ctrl+Shift+&lt;】减小字体大小【Ctrl+E】选中搜索框【Ctrl+H】在文档中替换【Ctrl+Home】移动到文档的开头【Ctrl+End】移动到文档的结尾]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[数学知识 自然数：非负整数；质数： 最大公约数： 排序堆排序堆排序的时间复杂度是O(nlgn)。 快速排序线性时间排序数据结构基本数据结构栈和队列栈和队列都是动态集合，且在其上进行DELETE操作所移除的元素是预先设定的。在栈（stack）中，被删除的是最近插入的元素：栈实现的是一种后进先出（last-in，first-out，LIFO）策略。类似的，队列（queue）中，被删去的总是在集合中存在时间最长的那个元素：队列实现的是一种先进先出（first-in，first-out，FIFO）策略。 栈上的INSERT操作称为压入（PUSH），而无元素参数的DELETE操作称为弹出（POP）。 队列 链表散列表二叉搜索树红黑树高级数据结构B树图算法基本的图算法最小生成树]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[android-命令行工具]]></title>
    <url>%2Fandroid-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[https://developer.android.google.cn/studio/command-line aapt2adbAndroid Debug Bridge（ADB），用于通过电脑端与设备交互。ADB是一个C/S架构的命令行工具，端口5037，如下图所示：adb client：运行在PC端；所有的client都是通过5037端口与adb server进行通信的。adb server：作为一个后台的程序运行在PC端的，负责管理client进程以及adb daemon之间的通信。当一个server开启的时候，会自动绑定并且监听5037端口，接收client通过该端口发送过来的命令。同时server扫描设备端口，进行对已连接设备的定位。adb daemon：每个设备/模拟器连接到PC端时，总会开启这么一个后台进程，并且为其分配了两个连续的端口。端口范围5554-5585，adb连接手机的最大数量是16。偶数端口用于server与设备进行交互的，可以让server直接从设备中读取数据，而奇数端口是用来与设备的adb进行连接通信的。 adb命令adb shell命令logcat]]></content>
      <categories>
        <category>android</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-行为型-中介者模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-行为型-访问者模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-行为型-模板方法模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-行为型-迭代器模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-行为型-备忘录模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-行为型-观察者模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[简介]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-行为型-命令模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-行为型-解释器模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-行为型-责任链模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-行为型-状态模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-行为型-策略模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-结构型-桥接模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[桥接模式（Bridge Pattern），是结构型设计模式之一。 定义 将抽象部分与实现部分分离，使它们都可以独立地进行变化。 使用场景如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，可以通过桥接模式使它们在抽象层建立一个关联关系。一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。 UML类图简单实现Android源码中的实现]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-结构型-外观模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-结构型-享元模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-结构型-装饰模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-结构型-适配器模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-结构型-组合模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-结构型-代理模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[简介 为其他对象提供一种代理以控制对这个对象的访问。 UML类图]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-创建型-原型模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-创建型-抽象工厂模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[简介 为创建一组相关或者是相互依赖的对象提供一个接口，而不需要指定它们的具体类。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-创建型-工厂方法模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[简介 定义一个用于创建对象的接口，让子类决定实例化哪个类。 UML类图通用模式分为如下角色： 抽象工厂，其为工厂方法模式的核心； 具体工厂，实现具体的业务逻辑； 抽象产品； 具体产品，实现抽象产品的某个具体产品的对象。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-创建型-Builder模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-Builder%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概述 Builder模式为了将构建复杂对象的过程和它的部件解耦，使得构建过程和部件的表示隔离开来。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-创建型-单例模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[简介 单例模式（Singleton），保证一个类仅有一个实例，并提供一个访问它的全局访问点。 实现单例模式主要有如下几个关键点： private构造方法，不对外开放； 通过一个公有静态方法或枚举返回单例类对象； 确保单例类的对象有且只有一个，尤其是在多线程环境下； 确保单例类对象在反序列化时不会重新构建对象。 123456789101112131415class Singleton &#123; private static Singleton instance; // 私有构造方法 private Singleton() &#123; &#125; // 获取本类实例的唯一全局访问点 public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 单例模式划分 懒汉式：声明一个静态对象，在第一次调用getInstance时进行初始化。缺点：第一次加载时需要及时进行实例化，反应稍慢。 饿汉式：在类加载时就完成了初始化。 单例实现方式 方法加锁（synchronized）。缺点：每次调用都进行同步，造成不必要的同步开销。12public static synchronized Singleton getInstance() &#123;&#125; 双重检查锁（DCL，Double Check Lock）。先判断对象是否已经初始化，再决定是否加锁。 123456789101112131415161718class Singleton &#123; // volatile会禁止指令重排。修饰的变量会强制将修改的值立即写入主存，主存中的值更新会使缓存中的值失效。 private volatile static Singleton instance; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 实例化对象instance = new Singleton();不是一个原子操作，会被编译成多条汇编指令： 给Singleton的实例分配内存； 调用构造方法，初始化对象； 将instance对象指向分配的内存空间。 由于Java编译器允许处理器乱序执行，以及JDK 1.5之前JMM（Java Memory Model，Java内存模型）中Cache、寄存器到主内存回写顺序的规定，上面的第二和第三的顺序是无法保证的。如果线程A执行完3，2未执行之前，切换到线程B上，再使用时就会出错，这就是DCL失效问题。JDK 1.5，SUN注意到这种问题，调整了JVM，具体化了volatile关键字，保证instance对象每次都是从主内存中读取。 静态内部类单例模式 123456789101112class Singleton &#123; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return SingletonHolder.instance; &#125; private static class SingletonHolder &#123; private static final Singleton instance = new Singleton(); &#125;&#125; 枚举单例上述的几种单例模式实现中，在反序列化的情况下会出现重新创建对象。 123enum SingletonEnum &#123; INSTANCE;&#125; 使用容器实现单例模式 优缺点优点：缺点： 单例对象如果持有Context，容易引发内存泄漏，此时需要注意传递给单例对象的Context最好是Application Context。 备注对象属于引用数据类型，和基本数据类型最大的不同在于引用数据类型需要进行内存分配，关键字new主要的功能就是开辟内存空间。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-面向对象六大原则]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[概览系统开发过程中，最难的不是完成系统的开发工作，而是在于后续的升级、维护过程中让系统能够拥抱变化。拥抱变化也就意味着在满足需求且不破坏系统稳定性的前提下保持高可扩展性、高内聚、低耦合，经历各版本的变更之后依然保持清晰、灵活、稳定的系统架构。当然，这是比较理想的情况，但我们必须朝着这个方向去努力，那么遵循面向对象六大原则就是我们走向灵活软件之路所迈出的第一步。 软件的可维护性和可复用性。 好的系统设计应该具备如下三个性质： 可扩展性（Extensibility） 灵活性（Flexibility） 可插入性（Pluggability） 可维护性较低的系统设计，通常有如下几个原因： 复用率低（Immobility） 黏度过高（Viscosity） 脆弱 僵硬 这些原则并不是孤立存在的，它们相互依赖，相互补充。 开闭原则（OCP）Open Close Principle，缩写OCP。开闭原则由Bertrand Meyer（勃兰特·梅耶）于1988年出版的《面向对象软件构造》一书中提出。抽象化是开闭原则的关键。 定义：软件中的对象（类、模块、函数等）应该对于扩展是开放的，对于修改是封闭的。 软件开发过程中，最不会变化的就是变化本事。 依赖倒置原则（DIP）Dependence Inversion Principle，缩写DIP。 定义：依赖倒置原则指代了一种特定的解耦形式，使得高层次的模块不依赖于低层次模块的实现细节的目的，依赖模块被颠倒了。 高层模块不应该依赖低层模块，两者都应该依赖其抽象 抽象不应该依赖细节 细节应该依赖抽象 java语言中，抽象就是指接口或抽象类，两者都不可以直接被实例化；细节就是实现类。高层模块就是调用端，低层模块就是具体实现类。 里氏替换原则（LSP）Liskov Substitution Principle，缩写LSP。 定义：所有引用基类的地方必须能透明地使用其子类的对象。 单一职责原则（SRP）Single Responsibility Principle，缩写SRP。 定义：就一个类而言，应该仅有一个引起它变化的原因。 接口隔离原则（ISP）InterfaceSegregation Principles，缩写ISP。 定义：客户端不应该依赖它不需要的接口。 迪米特原则（LOD）Law of Demeter，缩写LOD，也称为最少知识原则。 定义：一个对象应该对其他对象有最少的了解。 Only talk to your immedate friends。只与直接的朋友通信。？？？每个对象都必然会与其他对象有耦合关系，两个对象之间的耦合就称为朋友关系，如依赖、关联、组合、聚合等。 类应该对自己需要耦合或调用的类知道得最少，类的内部如何实现与调用者或依赖者没有关系，调用者或者依赖者只需要知道它需要的方法即可，其他的可一概不用管。类与类之间关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。软件总的原则：低耦合、高内聚。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>面向对象六大原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie-Session-Token-JWT]]></title>
    <url>%2FCookie-Session-Token-JWT%2F</url>
    <content type="text"><![CDATA[CookieCookie技术产生源于HTTP协议在互联网上的急速发展。随着互联网的深层次发展，带宽等限制不存在了，人们需要更复杂的互联网交互活动，就必须同服务器保持活动状态。于是，在浏览器发展初期，为了适应用户的需求，技术上推出了各种保持Web浏览状态的手段，其中就包括了Cookie技术。1993年，网景公司雇员Lou Montulli为了让用户在访问某网站时，进一步提高访问速度，同时也为了进一步实现个人化网络，发明了今天广泛使用的Cookie。Cookie在计算机中是个存储在浏览器目录中的文本文件，当浏览器运行时，存储在RAM中发挥作用（此种Cookies称作Session Cookies），一旦用户从该网站或服务器退出，Cookie可存储在用户本地的硬盘上（此种Cookies称作Persistent Cookies）。特点： Cookie时效性 同一个页面中设置Cookie，实际上是按从后往前的顺序进行的。 Cookie必须在HTML文件的内容输出之前设置 不同的浏览器对Cookie的处理不一致，使用时一定要考虑。 客户端，一个浏览器能创建的Cookie数量最多为300个，并且每个不能超过4KB，每个Web站点能设置的Cookie总数不能超过20个。 工作流程： Web Client - HTTP Request -&gt; Web Server Web Server - HTTP Response + Set-Cookie -&gt; Web Client Web Client - HTTP Request + Cookie -&gt; Web Server Web Server - HTTP Response -&gt; Web Client SessionSession是对于服务端来说的，客户端是没有Session一说的。Session是服务器和客户端建立连接时添加客户端连接标志，最终会在服务器软件（Apache、Tomcat、JBoss）转化为一个临时Cookie发送给客户端。Session就是在一次会话中解决2次HTTP的请求的关联，让两个页面都能读取到这个全局的session信息。 TokenToken是用户身份的验证方式，通常叫它：令牌。 JWTJWT（JSON Web Token）是目前最流行的跨域身份验证解决方案。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[持续集成CI]]></title>
    <url>%2F%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90CI%2F</url>
    <content type="text"><![CDATA[引言持续集成是一种软件开发实践，团队内开发成员经常集成工作，。每次集成通过自动化的构建（编译、自动化测试）来验证，从而尽早发现集成错误。Martin Fowler文章：https://martinfowler.com/articles/continuousIntegration.html Jenkins简介Jenkins最初由Sun Microsystems公司在2005年作为Hudson发布的。多年来，已经成长为Java社区最流行的CI系统。Jenkins的强大之处在于它的插件系统。如果构建系统中有新的功能需求，可以创建一个新的插件来扩展Jenkins的能力。 设置 Manage Jenkins | Configure System，Global properties添加如下环境变量：ANDROID_HOME和JAVA_HOME Manage Jenkins | Manage Plugins，安装Gradle插件。 配置VCS仓库，以便Jenkins知道从哪里获取项目源码。 Invoke Gradle script PluginsSonarQubeSonarQube Scanner for Jenkins TeamCityTravis CI如果项目仓库是在GitHub上托管的，则可以使用Travis CI来自动构建。]]></content>
      <categories>
        <category>软件开发工具</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-学习篇-Fragment]]></title>
    <url>%2Fandroid-%E5%AD%A6%E4%B9%A0%E7%AF%87-Fragment%2F</url>
    <content type="text"><![CDATA[概览Android 3.0（API级别11）中引入了Fragment，主要是为了给大屏幕（如平板电脑）上更加动态和灵活的 UI 设计提供支持。由于平板电脑的屏幕比手机屏幕大得多，因此可用于组合和交换 UI 组件的空间更大。利用片段实现此类设计时，您无需管理对视图层次结构的复杂更改。 Fragment表示Activity中的行为或用户界面部分。Fragment必须始终嵌入在Activity中，其生命周期直接受宿主Activity生命周期的影响。 可以将多个Fragment组合在一个Activity中来构建多窗格UI，以及在多个Activity中重复使用某个片段。 可以将Fragment视为Activity的模块化组成部分，它具有自己的生命周期，能接收自己的输入事件。 可以在Activity运行时添加或移除Fragment。 优势： 模块化（Modularity）：不必把所有代码全部写在Activity中，而是把代码写在各自的Fragment中。 可重用（Reusability）：多个Activity可以重用一个Fragment。 可适配（Adaptability）：根据硬件的屏幕尺寸、屏幕方向，能够方便地实现不同的布局，这样用户体验更好。 生命周期lifecycle onAttach()：Fragment与Activity关联时调用。 onCreate()：创建Fragment时调用。 onCreateView()：首次绘制其用户界面时调用。 onActivityCreated()：在Activity的onCreate()方法已返回时调用。 FragmentManagerFragmentManager findFragmentById() findFragmentByTag() popBackStack()：将Fragment从返回栈中弹出。 addOnBackStackChangedListener()：返回栈变化监听。 FragmentTransactionFragmentTransaction根据用户行为执行添加add()、移除remove()、替换replace()以及其他操作的事务。12345678// Activity中获取FragmentTransaction实例FragmentManager fragmentManager = getFragmentManager();FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();// add()ExampleFragment fragment = new ExampleFragment();fragmentTransaction.add(R.id.fragment_container, fragment);fragmentTransaction.commit(); 以下示例说明了如何将一个片段替换成另一个片段，以及如何在返回栈中保留先前状态：1234567891011// Create new fragment and transactionFragment newFragment = new ExampleFragment();FragmentTransaction transaction = getFragmentManager().beginTransaction();// Replace whatever is in the fragment_container view with this fragment,// and add the transaction to the back stacktransaction.replace(R.id.fragment_container, newFragment);transaction.addToBackStack(null);// Commit the transactiontransaction.commit(); 提示：对于每个片段事务，您都可以通过在提交前调用 setTransition() 来应用过渡动画。调用commit()不会立即执行事务，而是在Activity的UI线程可以执行该操作时再安排其在线程上运行。不过，如有必要，您也可以从UI 线程调用executePendingTransactions()以立即执行commit()提交的事务。通常不必这样做，除非其他线程中的作业依赖该事务。注意：您只能在Activity保存其状态（用户离开 Activity）之前使用commit()提交事务。如果您试图在该时间点后提交，则会引发异常。 这是因为如需恢复Activity，则提交后的状态可能会丢失。 对于丢失提交无关紧要的情况，请使用 commitAllowingStateLoss()。 与Activity通信 Fragment可以通过getActivity()访问Activity实例。 Activity可以通过FragmentManager对象调用findFragmentById()或findFragmentByTag()获取对Fragment的引用]]></content>
      <categories>
        <category>android</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-学习篇-AndroidManifest]]></title>
    <url>%2Fandroid-%E5%AD%A6%E4%B9%A0%E7%AF%87-AndroidManifest%2F</url>
    <content type="text"><![CDATA[概览官方文档每个应用的根目录中都必须包含一个AndroidManifest.xml文件（且文件名精确无误）。清单文件向Android系统提供应用的必要信息，系统必须具有这些信息方可运行应用的任何代码。清单文件示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest&gt; &lt;uses-permission /&gt; &lt;permission /&gt; &lt;permission-tree /&gt; &lt;permission-group /&gt; &lt;instrumentation /&gt; &lt;uses-sdk /&gt; &lt;uses-configuration /&gt; &lt;uses-feature /&gt; &lt;supports-screens /&gt; &lt;compatible-screens /&gt; &lt;supports-gl-texture /&gt; &lt;application&gt; &lt;activity&gt; &lt;intent-filter&gt; &lt;action /&gt; &lt;category /&gt; &lt;data /&gt; &lt;/intent-filter&gt; &lt;meta-data /&gt; &lt;/activity&gt; &lt;activity-alias&gt; &lt;intent-filter&gt; . . . &lt;/intent-filter&gt; &lt;meta-data /&gt; &lt;/activity-alias&gt; &lt;service&gt; &lt;intent-filter&gt; . . . &lt;/intent-filter&gt; &lt;meta-data/&gt; &lt;/service&gt; &lt;receiver&gt; &lt;intent-filter&gt; . . . &lt;/intent-filter&gt; &lt;meta-data /&gt; &lt;/receiver&gt; &lt;provider&gt; &lt;grant-uri-permission /&gt; &lt;meta-data /&gt; &lt;path-permission /&gt; &lt;/provider&gt; &lt;uses-library /&gt; &lt;/application&gt;&lt;/manifest&gt; action在intent-filter内部使用。1&lt;action android:name="string" /&gt; activity1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;activity android:allowEmbedded=["true" | "false"] android:allowTaskReparenting=["true" | "false"] android:alwaysRetainTaskState=["true" | "false"] android:autoRemoveFromRecents=["true" | "false"] android:banner="drawable resource" android:clearTaskOnLaunch=["true" | "false"] android:colorMode=[ "hdr" | "wideColorGamut"] android:configChanges=["mcc", "mnc", "locale", "touchscreen", "keyboard", "keyboardHidden", "navigation", "screenLayout", "fontScale", "uiMode", "orientation", "density", "screenSize", "smallestScreenSize"] android:directBootAware=["true" | "false"] android:documentLaunchMode=["intoExisting" | "always" | "none" | "never"] android:enabled=["true" | "false"] android:excludeFromRecents=["true" | "false"] android:exported=["true" | "false"] android:finishOnTaskLaunch=["true" | "false"] android:hardwareAccelerated=["true" | "false"] android:icon="drawable resource" android:immersive=["true" | "false"] android:label="string resource" android:launchMode=["standard" | "singleTop" | "singleTask" | "singleInstance"] android:lockTaskMode=["normal" | "never" | "if_whitelisted" | "always"] android:maxRecents="integer" android:maxAspectRatio="float" android:multiprocess=["true" | "false"] android:name="string" android:noHistory=["true" | "false"] android:parentActivityName="string" android:persistableMode=["persistRootOnly" | "persistAcrossReboots" | "persistNever"] android:permission="string" android:process="string" android:relinquishTaskIdentity=["true" | "false"] android:resizeableActivity=["true" | "false"] android:screenOrientation=["unspecified" | "behind" | "landscape" | "portrait" | "reverseLandscape" | "reversePortrait" | "sensorLandscape" | "sensorPortrait" | "userLandscape" | "userPortrait" | "sensor" | "fullSensor" | "nosensor" | "user" | "fullUser" | "locked"] android:showForAllUsers=["true" | "false"] android:stateNotNeeded=["true" | "false"] android:supportsPictureInPicture=["true" | "false"] android:taskAffinity="string" android:theme="resource or theme" android:uiOptions=["none" | "splitActionBarWhenNarrow"] android:windowSoftInputMode=["stateUnspecified", "stateUnchanged", "stateHidden", "stateAlwaysHidden", "stateVisible", "stateAlwaysVisible", "adjustUnspecified", "adjustResize", "adjustPan"] &gt; . . .&lt;/activity&gt; 可包含：intent-filtermeta-datalayout application 属性 说明 添加版本 android:allowBackup 是否允许用户备份应用信息 Android 2.2 android:roundIcon 只适用7.1，被8.0系统应用图标适配替代 Android 7.1 android:supportsRtl 支持从右到左布局 Android 4.2 注意：android:allowBackup=”true”，安全漏洞问题。Android 8.0自适应图标方案（res\mipmap-anydpi-v26）： foreground：需要显示的主icon background：底层背景图案 Mask：遮罩，由手机设备厂商提供 123456789101112131415&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.android.exp"&gt; &lt;application android:name=".MyApplication" android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;/application&gt;&lt;/manifest&gt; categorydata在intent-filter内部使用。1234567&lt;data android:scheme="string" android:host="string" android:port="string" android:path="string" android:pathPattern="string" android:pathPrefix="string" android:mimeType="string" /&gt; intent-filtermanifestmeta-datauses-configurationuses-featureuses-libraryuses-permission官方文档1234&lt;manifest ... &gt; &lt;uses-permission android:name="android.permission.SEND_SMS"/&gt; ...&lt;/manifest&gt; uses-permission-sdk-23uses-sdk清单文件示例1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" android:versionCode="1" android:versionName="1.0" package="com.example.myapp"&gt; &lt;!-- Beware that these values are overridden by the build.gradle file --&gt; &lt;uses-sdk android:minSdkVersion="15" android:targetSdkVersion="26" /&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:roundIcon="@mipmap/ic_launcher_round" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;!-- This name is resolved to com.example.myapp.MainActivity based upon the package attribute --&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=".DisplayMessageActivity" android:parentActivityName=".MainActivity" /&gt; &lt;/application&gt;&lt;/manifest&gt;]]></content>
      <categories>
        <category>android</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-学习篇-Activity]]></title>
    <url>%2Fandroid-%E5%AD%A6%E4%B9%A0%E7%AF%87-Activity%2F</url>
    <content type="text"><![CDATA[&lt;activity>1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;activity android:allowEmbedded=["true" | "false"] android:allowTaskReparenting=["true" | "false"] android:alwaysRetainTaskState=["true" | "false"] android:autoRemoveFromRecents=["true" | "false"] android:banner="drawable resource" android:clearTaskOnLaunch=["true" | "false"] android:colorMode=[ "hdr" | "wideColorGamut"] android:configChanges=["mcc", "mnc", "locale", "touchscreen", "keyboard", "keyboardHidden", "navigation", "screenLayout", "fontScale", "uiMode", "orientation", "density", "screenSize", "smallestScreenSize"] android:directBootAware=["true" | "false"] android:documentLaunchMode=["intoExisting" | "always" | "none" | "never"] android:enabled=["true" | "false"] android:excludeFromRecents=["true" | "false"] android:exported=["true" | "false"] android:finishOnTaskLaunch=["true" | "false"] android:hardwareAccelerated=["true" | "false"] android:icon="drawable resource" android:immersive=["true" | "false"] android:label="string resource" android:launchMode=["standard" | "singleTop" | "singleTask" | "singleInstance"] android:lockTaskMode=["normal" | "never" | "if_whitelisted" | "always"] android:maxRecents="integer" android:maxAspectRatio="float" android:multiprocess=["true" | "false"] android:name="string" android:noHistory=["true" | "false"] android:parentActivityName="string" android:persistableMode=["persistRootOnly" | "persistAcrossReboots" | "persistNever"] android:permission="string" android:process="string" android:relinquishTaskIdentity=["true" | "false"] android:resizeableActivity=["true" | "false"] android:screenOrientation=["unspecified" | "behind" | "landscape" | "portrait" | "reverseLandscape" | "reversePortrait" | "sensorLandscape" | "sensorPortrait" | "userLandscape" | "userPortrait" | "sensor" | "fullSensor" | "nosensor" | "user" | "fullUser" | "locked"] android:showForAllUsers=["true" | "false"] android:stateNotNeeded=["true" | "false"] android:supportsPictureInPicture=["true" | "false"] android:taskAffinity="string" android:theme="resource or theme" android:uiOptions=["none" | "splitActionBarWhenNarrow"] android:windowSoftInputMode=["stateUnspecified", "stateUnchanged", "stateHidden", "stateAlwaysHidden", "stateVisible", "stateAlwaysVisible", "adjustUnspecified", "adjustResize", "adjustPan"] &gt; &lt;intent-filter&gt; &lt;meta-data&gt; &lt;layout&gt; . . .&lt;/activity&gt; 详细介绍 生命周期 onCreate() onStart() onResume() onPause() onStop() onDestroy() 保存和恢复状态onSaveInstanceState()onRestoreInstanceState() 注意：当用户显式关闭 Activity 时，或者在其他情况下调用 finish() 时，系统不会调用onSaveInstanceState() Activity间导航startActivity()startActivityForResult() 任务和返回栈任务是用户在执行某项工作时与之互动的一系列 Activity 的集合。这些 Activity 按照每个 Activity 打开的顺序排列在一个返回堆栈中。Android 7.0（API 24）及更高版本支持多窗口环境，当应用在这种环境中同时运行时，系统会单独管理每个窗口的任务；而每个窗口可能包含多项任务。 Android 7.0支持分屏模式。 Android 8.0 开始，应用可以将自身置于画中画模式，从而使其能在用户浏览其他应用或与之交互时继续显示内容。 启动模式 standard singleTop singleTask singleInstance]]></content>
      <categories>
        <category>android</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-学习篇-基础知识]]></title>
    <url>%2Fandroid-%E5%AD%A6%E4%B9%A0%E7%AF%87-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[四大组件ActivityBroadcastReceiverServiceService分为两种工作状态： 启动状态，主要用于执行后台计算。 绑定状态，主要用于其他组件和Service的交互。 ContentProviderIntenthttps://developer.android.google.cn/guide/components/intents-filters.html Animator 逐帧动画：Drawable Animation。res/anim，android：oneshot是否循环播放 补间动画：Tween Animation 属性动画（Android 3.0） android.transition（Android 4.4）：本质属性动画。 Tween AnimationAlpha-Scale-Translate-RotateInterpolator（插值器） Property Animation Evaluator：控制属性动画如何计算属性值的。 AnimatorSet ValueAnimator ObjectAnimator：ValueAnimator子类。 android.transition应用资源res/https://developer.android.google.cn/guide/topics/resources/providing-resources应该始终外部化应用资源，如图像和代码中的字符串，有利于单独维护这些资源。此外，还应为特定设备配置提供备用资源，方法是将它们分组到专门命名的资源目录中。res/目录支持的资源目录，如下： animator/：定义属性动画的XML文件。 anim/：定义渐变动画的XML文件。（属性动画也可以放在该目录，一般为了区分，首选上面的目录。） color/ drawable/ mipmap/：适用于不同启动器图标密度的可绘制对象文件。 layout/ menu/ raw/：以原始形式保存的文件。但是，如需访问原始文件名和文件层次结构，则可以考虑将某些资源保存在 assets/目录下 values/ xml/：可以在运行时通过调用Resources.getXML()读取的任意XML文件。 提供备用资源在res/中创建一个以&lt;resources_name&gt;-&lt;config_qualifier&gt;形式命名的新目录。 配置 限定符值 说明 屏幕像素密度 (dpi) ldpi、mdpi、hdpi、xhdpi、xxhdpi、xxxhdpi、nodpi、tvdpi、anydpi XML解析方式SAXDOMPullNDK(Native Develop Kit)https://developer.android.google.cn/ndk原生开发工具包（NDK）是一套工具，允许您为 Android 使用C和C++代码，并提供众多平台库，您可用其管理原生Activity和访问物理设备组件，例如传感器和触摸输入。借助Android Studio 2.2或更高版本，使用NDK将C和C++代码编译到原生库中，然后使用IDE集成构建系统 Gradle将您的库封装入APK。然后，Java代码可以通过Java原生接口 (JNI) 框架，调用您原生库中的函数。Android Studio用于编译原生库的默认构建工具是CMake。由于很多现有项目都使用构建工具包，因此Android Studio也支持ndk-build。不过，如果您要创建新的原生库，则应使用 CMake。 使用场景 在平台之间移植其应用。 进一步提升设备性能，以实现低延迟时间，或运行计算密集型应用，如游戏或物理模拟。 重复使用自己或其他开发者的C或C++库。 编译和调试原生代码组件Android 原生开发工具包 (NDK)：这套工具允许您为 Android 使用 C 和 C++ 代码。CMake：一款外部构建工具，可与 Gradle 搭配使用来构建原生库。如果您只计划使用 ndk-build，则不需要此组件。LLDB：一种调试程序，Android Studio 使用它来调试原生代码。安装：Tools &gt; SDK Manager 创建或导入原生项目工作原理CPU和架构使用原生代码时，硬件很重要。NDK提供各种ABI供您选择，可让您确保针对正确的架构和CPU进行编译。 ABI不同的Android手机使用不同的CPU，进而支持不同的指令集。CPU与指令集的每种组合都有专属的应用二进制界面，即ABI。ABI可以非常精确地定义应用的机器代码在运行时如何与系统交互。您必须为应用要使用的每个CPU架构指定ABI。 参考开发者指南API reference]]></content>
      <categories>
        <category>android</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-学习篇-系统架构]]></title>
    <url>%2Fandroid-%E5%AD%A6%E4%B9%A0%E7%AF%87-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Linux kernelAndroid平台的基础是Linux内核。使用Linux内核可让Android利用主要安全功能，并且允许设备制造商为著名的内核开发硬件驱动程序。在操作系统级别，Android平台不仅提供Linux内核的安全功能，而且还提供安全的进程间通信（IPC）机制，以便在不同进程中运行的应用之间安全通信。操作系统级别的这些安全功能旨在确保即使是原生代码也要受应用沙盒的限制。Linux内核为Android提供了一些关键的安全功能，包括： 基于用户的权限模式 进程隔离 用于实现安全IPC的可扩展机制 能够移除内核中不必要的和可能不安全的部分 Android的应用安全性是由应用沙盒强制实施的。 HAL硬件抽象层（HAL）提供标准界面，向更高级别的Java API框架显示设备硬件功能。HAL包含多个库模块，其中每个模块都为特定类型的硬件组件实现一个界面，例如相机或蓝牙模块。当Java API框架要求访问设备硬件时，Android系统将为该硬件组件加载库模块。 相机蓝牙Android 8.0 架构蓝牙应用通过Binder与蓝牙进程进行通信。蓝牙进程使用JNI与蓝牙堆栈通信，并向开发者提供对各种蓝牙配置文件的访问权限。android.bluetooth 原生C/C++库许多核心Android系统组件和服务（例如ART和HAL）构建自原生代码，需要以C和C++编写的原生库。Android 平台提供Java框架API以向应用显示其中部分原生库的功能。例如，您可以通过Android框架的Java OpenGL API访问OpenGL ES，以支持在应用中绘制和操作2D和3D图形。如果开发的是需要C或C++代码的应用，可以使用Android NDK直接从原生代码访问某些原生平台库。 Android RuntimeAndroid 5.0（API 21）或更高版本，每个应用都在其自己的进程中运行，并且有其自己的Android Runtime（ART）实例。ART编写为通过执行DEX文件在低内存设备上运行多个虚拟机，DEX文件是一种专为Android设计的字节码格式，经过优化，使用的内存很少。编译工具链（例如Jack已被弃用）将Java源代码编译为DEX字节码，使其可在Android平台上运行。ART的部分主要功能包括： 预先 (AOT) 和即时 (JIT) 编译 优化的垃圾回收 (GC) 更好的调试支持，包括专用采样分析器、详细的诊断异常和崩溃报告，并且能够设置监视点以监控特定字段 Android 5.0（API 21）之前，Dalvik是Android Runtime。如果您的应用在ART上运行效果很好，那么它应该也可在 Dalvik 上运行，但反过来不一定。Android还包含一套核心运行时库，可提供Java API框架使用的Java 编程语言大部分功能，包括一些Java 8语言功能。 Java API Framework您可通过以Java语言编写的API使用Android OS的整个功能集。这些API形成创建Android应用所需的构建块，它们可简化核心模块化系统组件和服务的重复使用，包括以下组件和服务： 丰富、可扩展的视图系统，可用以构建应用的 UI，包括列表、网格、文本框、按钮甚至可嵌入的网络浏览器 资源管理器，用于访问非代码资源，例如本地化的字符串、图形和布局文件 通知管理器，可让所有应用在状态栏中显示自定义提醒 Activity管理器，用于管理应用的生命周期，提供常见的导航返回栈 内容提供程序，可让应用访问其他应用（例如“联系人”应用）中的数据或者共享其自己的数据开发者可以完全访问Android系统应用使用的框架API。 应用程序层用户直接可见的应用程序。 参考https://developer.android.google.cn/guide/platform/]]></content>
      <categories>
        <category>android</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-历史版本]]></title>
    <url>%2Fandroid-%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[官方地址android-系统架构preview android 10 - API 292019年9月10日发布。 支持可折叠 5G网络 智能回复通知 黑色主题 手势导航 Settings Panels Sharing shortcuts 提升用户隐私 安全 相机和媒体 Connectivity Android foundations Faster updates, fresher code android 9.0 - API 282018年8月7日发布，代号Pie。Android 9.0 Pie WIFI RTT进行室内定位Android 9添加了对IEEE 802.11mc Wi-Fi协议（也称为Wi-Fi Round-Trip-Time(RTT)）的平台支持，从而让您的应用可以利用室内定位功能。在运行Android 9且具有硬件支持的设备上，应用可以使用RTT API来测量与附近支持RTT的Wi-Fi接入点(AP)的距离。设备必须已启用位置服务并开启Wi-Fi扫描（在 Settings &gt; Location 下），同时您的应用必须具有ACCESS_FINE_LOCATION权限。 显示屏缺口支持Android 9支持最新的全面屏，其中包含为摄像头和扬声器预留空间的屏幕缺口。通过DisplayCutout类可确定非功能区域的位置和形状，这些区域不应显示内容。要确定这些屏幕缺口区域是否存在及其位置，请使用 getDisplayCutout()) 函数。 通知动画自动填充框架安全增强功能Android备份无障碍功能旋转文本设备端系统跟踪android 8.1 - API 272017年12月5日发布。 android 8.0 - API 262017年8月22日发布，代号Oreo（奥利奥）。Android 8.0 Oreo android 7.1 - API 252016年12月5日发布。 android 7.0 - API 242016年8月22日发布，代号Nougat（牛轧糖）。Android 7.0 Nougat android 6.0 - API 232015年5月28日发布，代号Marshmallow（棉花糖）。Android 6.0 Marshmallow android 5.1 - API 22android 5.0 - API 212014年10月15日发布，代号Lollipop（）Android 5.0 Lollipop扩展了Android的应用范围，从手机、平板电脑和可穿戴式设备，扩展到电视和汽车。 Material Design以性能为中心通知android 4.4W - API 20android 4.4 - API 19Android 4.4 KitKat android 4.3 - API 18android 4.2-4.2.2 - API 17android 4.1-4.1.1 - API 16android 4.0.3–4.0.4 - API 15android 4.0 - API 14android 1.0 - API 12008年，在Google I/O大会上，谷歌提出了Android HAL架构图。2008年9月，正式发布了Android 1.0系统。]]></content>
      <categories>
        <category>android</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-学习篇-网络编程]]></title>
    <url>%2Fjava-%E5%AD%A6%E4%B9%A0%E7%AF%87-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[基础知识IP地址 IPv4：4个字节。 IPv6：16个字节。 端口号 每个程序在设备上的唯一标识 端口号范围为0~65535 常用端口mysql(3306)；oracle(1521)；web(80)；tomcat(8080) 协议 TCP（传输控制协议）：面向连接的、可靠的字节流服务。 UDP（用户数据报协议） Socket123456789101112131415161718192021222324252627// 简单UDP数据传输// 发送者public class Sender &#123; public static void main(String[] args) throws Exception &#123; DatagramSocket sender = new DatagramSocket(); byte[] data = "hello socket".getBytes("UTF-8"); DatagramPacket packet = new DatagramPacket(data, data.length, Inet4Address.getByName("192.168.x.x"), 5001); sender.send(packet); sender.close(); &#125;&#125;// 接收者public class Receiver &#123; public static void main(String[] args) throws IOException &#123; DatagramSocket receiver = new DatagramSocket(5001); byte[] data = new byte[1024]; DatagramPacket packet = new DatagramPacket(data, data.length); receiver.receive(packet); receiver.close(); System.out.println("接收数据：" + new String(data, "UTF-8")); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-源码篇-HashMap]]></title>
    <url>%2Fjava-%E6%BA%90%E7%A0%81%E7%AF%87-HashMap%2F</url>
    <content type="text"></content>
      <categories>
        <category>java</category>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-学习篇-集合]]></title>
    <url>%2Fjava-%E5%AD%A6%E4%B9%A0%E7%AF%87-%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[概述所有的集合类都位于java.util包下，后来为了处理多线程环境下的并发安全问题，Java 5还在java.util.concurrent包下提供了一些多线程支持的集合类。Java的集合类主要由两个接口派生而出：Collection和Map，是Java集合框架的根接口，这两个接口又包含了一些子接口或实现类。 Collection子接口如下所示： Set（无序，元素不可重复） List（有序，元素可以重复） Queue（队列） Collection接口定义的方法：123456789101112131415161718// java.utilpublic interface Collection&lt;E&gt; extends Iterable&lt;E&gt;int size();boolean isEmpty();boolean contains(Object o);// 返回Iterator对象，用于遍历集合里的元素。Iterator&lt;E&gt; iterator();// 将集合转换成数组Object[] toArray();Iterator&lt;E&gt; iterator();boolean add(E e);boolean remove(Object o);boolean containsAll(Collection&lt;?&gt; c);boolean addAll(Collection&lt;? entends E&gt; c);// 取交集boolean retainAll(Collection&lt;?&gt; c);void clear(); 遍历集合 Java 8使用Lambda表达式来遍历集合元素（Iterable接口新增forEach默认方法） Iterator（迭代器） Java 5提供foreach IteratorIterator仅用于遍历集合，Iterator本身并不提供盛装对象的能力。如果需要创建Iterator对象，则必须有一个被迭代的集合。12345678910111213141516// java.utilpublic interface Iterator&lt;E&gt;// 如果被迭代的集合元素还没有被遍历完，则返回trueboolean hasNext();// 返回集合里的下一个元素E next();default void remove() &#123; throw new UnsupportedOperationException("remove");&#125;// java 8为Iterator新增的默认方法default void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); while (hasNext()) action.accept(next());&#125; 注：Iterator迭代访问Collection集合元素时，Collection集合里的元素不能被改变。 List元素有序、可重复的集合。1public interface List&lt;E&gt; extends Collection&lt;E&gt; ArrayList线程不安全 LinkedListLinkedList与ArrayList、ArrayDeque的实现机制完全不同，后者内部以数组的形式来保存集合中的元素，随机访问有较好性能；而LinkedList内部以链表的形式来保存元素，插入、删除元素时性能比较好。 Vector线程安全，比ArrayList的性能低。子类Stack SetHashSetLinkedHashSetSortedSet(接口)TreeSetEnumSetQueuePriorityQueueDeque(接口)双端队列。 ArrayDequeArrayList和ArrayDeque两个集合类的实现机制基本相似，底层都采用一个动态的、可重分配的Object[]数组来存储集合元素，当集合元素超出了该数组的容量时，系统会在底层重新分配一个Object[]数组来存储集合元素。 MapMap保存的每项数据都是key-value对。Map中key是不可以重复的，key用于标识集合里的每项数据。 HashMap 线程不安全 可以使用null作为key或value。 LinkedHashMap父类为HashMap SortedMap(接口)实现类TreeMap。 TreeMapTreeMap就是一个红黑树数据结构，每个key-value对即作为红黑树的一个节点。 EnumMapHashtable]]></content>
      <categories>
        <category>java</category>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-学习篇-基础知识]]></title>
    <url>%2Fjava-%E5%AD%A6%E4%B9%A0%E7%AF%87-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[一次编译，到处运行。write once,run anywhere! 标识符和关键字分隔符：分号（;）、花括号（{}）、方括号（[]）、圆括号（()）、空格、圆点（.）标识符就是用于给程序中变量、类、方法命名的符号。Java语言的标识符必须以字母、下划线、美元符开头，后面可以跟任意数目的字母、数字、下划线和美元符。 Java语言是区分大小写的。 Java中所有的关键字都是小写的。 数据类型Java是强类型语言，强类型包含两方面的含义： 所有的变量必须先声明、后使用 指定类型的变量只能接受类型与之匹配的值 Java数据类型分为两类：基本类型和引用类型。8中基本数据类型： byte：1个字节（-128~127） short：2个字节 int：4个字节 long：8个字节 float：4个字节 double：8个字节 char：2个字节 boolean：1个字节 引用数据类型：类、接口、数组、枚举、注解 Java中整数值有4种表示方式：十进制、二进制（0B）、八进制（0）、十六进制（0X） 原码：最高位为符号位，0代表正数，1代表负数。反码：正数的反码是原码；负数的反码在原码基础上，符号位不变，其他位取反。补码：正数的补码是原码；负数的补码是其反码加1。为了解决原码做减法的问题，出现了反码；为了解决-0，出现了补码。计算机是以补码的形式保存所有的整数。8位二进制，原码与反码表示范围是[-127,127]，而使用补码表示范围是[-128,127] 字符集与编码 Java语言所提供的7种数值类型之间可以相互转换，两种转换方式：自动类型转换和强制类型转换。 运算符 算术运算符 赋值运算符 比较运算符 逻辑运算符 位运算符：&amp;、|、~（按位非）、^（按位异或）、&lt;&lt;（左移运算符）、&gt;&gt;（右移运算符）、&gt;&gt;&gt;（无符号右移运算符） 类型相关运算符 &gt;&gt;：右移运算符，右移n位相当于除以2的n次方&lt;&lt;：左移运算符，左移n位相当于乘以2的n次方&gt;&gt;&gt;：无符号右移例：2乘以8最有效率的方法是，2&lt;&lt;3；因为位运算是CPU直接支持的，效率最高。 控制流 分支结构：if和switch 循环结构：while、do while、for、foreach（JDK 5支持） foreach:for (type variableName : array | collection) {// variableName 自动迭代访问每个元素…}switch支持byte、short、char、int、枚举类型、String（Java 7支持）do {//至少执行一次} while();break不仅结束其所在的循环，还可以直接结束其外层循环。跳出多重循环时，可以使外层的循环条件表达式的结果受到里层循环体代码的控制。 数组数组的初始化完成，在内存中所占的空间将被固定下来，因此数组长度不可改变。 静态初始化：arrayName = new type[]{element1,element2…} 动态初始化：arrayName = new type[length] 数组是一种引用数据类型，数组引用变量只是一个引用，数组元素和数组变量在内存里是分开存放的。实际的数组对象存储在堆（Heap）内存中；如果引用该数组对象的数组引用变量是局部变量，存储在栈（Stack）内存中。 每个方法执行时，建立自己的内存栈，方法内部定义的变量将会逐个放入这块栈内存里，方法结束，内存栈自然销毁；在程序中创建一个对象时，这个对象被保存到运行时数据区，方便反复利用，这个运行时数据区就是堆内存。 面向对象类是对象的抽象；对象则是类的实例。类不是一种具体存在，实例才是具体存在。类：类加载、类验证、类准备、类解析、类初始化。“基于对象”（JavaScript）没有继承的特点；java不允许直接访问对象，而是通过对对象的引用来操作对象。 引用变量（指针）里存放的仅仅是一个引用（地址值），它指向实际的对象。堆内存里的对象可以有多个引用，即多个引用变量指向同一个对象。 this总是指向调用该方法的对象。最大的作用就是让类中一个方法，访问该类里的另一个方法或实例变量。 java里方法的参数传递方式只有一种：值传递。（副本） java把内存划分为两种：栈内存和堆内存。栈内存当超过变量的作用域后，java会自动释放为该变量分配的内存空间；堆内存用来存放由new创建的对象和数组，在堆中分配的内存，由java虚拟机的自动垃圾回收器来管理。 JDK 1.5后，Java允许定义形参个数可变的参数。只能处于最后一个形参，类型后（…），多个参数值被当成数组传入。 封装继承 overload（重载） override（方法覆盖） super当程序创建一个子类对象时，系统不仅会为该类中定义的实例变量分配内存，也会为它从父类继承得到的所有实例变量分配内存。 多态java引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。如果编译时类型和运行时类型不一致，就出现多态。 static static修饰的成员不能访问没有static修饰的成员。 static修饰的成员表明它属于这个类本身，而不属于该类的单个实例。 finalfinal修饰变量称为常量。常量命名规范，字母大写，单词间用下划线分开。如public static final KEY_MAN; final成员变量可以指定默认值，也可以在构造器或初始化块中分配初始值。 final修饰的形参不能赋值 final引用类型变量，引用地址不变，但对象属性可以发生改变。 final方法不可被重写，Object类getClass()；可以被重载。 final类不可以有子类 抽象类抽象方法和抽象类： 抽象类里可以没有抽象方法。抽象方法不能有方法体。 抽象类不能被实例化。抽象类的构造器不能用于创建实例，主要用于被其子类调用。 final和abstract永远不能同时使用。（abstract修饰类只能被继承，修饰方法必须由子类重写；fina修饰类不能被继承，修饰方法不能被重写） abstract不能用于修饰成员变量和局部变量；不能修饰构造器。 static和abstract不能同时修饰某个方法，但可以同时修饰内部类。abstract修饰方法不能定义为private访问权限。 抽象类体现的是一种模板模式的设计。 接口内部类内部类主要用于设计具有相互协作关系的类集合。 匿名内部类匿名内部类适合创建只需要一次使用的类。 匿名内部类不能是抽象类。 匿名内部类不能定义构造器。匿名内部类没有类名。 枚举Java从JDK1.5开始支持枚举。添加了抽象类java.lang.Enum，在枚举中可以定义属性、构造方法、普通方法、抽象方法。一个Java源文件最多只能定义一个public访问权限的枚举类，且该Java源文件必须和该枚举类的类名相同。可以像使用普通的类一样使用枚举，编译器做了些什么？欲知详情，最有效的途径就是查看生成的字节码。 泛型Java SE 5新增泛型（实现了参数化类型的概念）概念。编写可以应用于各种类型的代码。类型参数，用尖括号括住，放在类名后面。然后在使用这个类的时候，再用实际的类型替换此类型参数。元组（&lt;A,B,C…&gt;） 注解引言每当创建描述符性质的类或接口时，一旦其中包含了重复性的工作，那就可以考虑使用注解来简化与自动化该过程。Android中有两种应用方式，一种方式是基于反射的，即在程序的运行期间获取类信息进行反射调用；另一种是使用注解处理，在编译期间生成许多代码，然后在运行期间通过调用这些代码来实现目标功能。Java中注解分为标准注解和元注解。标准注解是Java为我们提供的预定义的注解，共有四种：@Override、@Deprecated、@SuppressWarnnings和@SafeVarags。元注解是用来提供给用户自定义注解用的，共有五种（截止Java8） @Target定义注解将应用于什么地方（如是一个方法或一个域）ElementType @Retention定义该注解在哪一个级别可用。RetentionPolicy枚举： SOURCE：注解将被编译器丢弃 CLASS：注解在class文件中使用，但会被JVM丢弃 RUNTIME：在运行期保留注解，可以通过反射读取注解的信息 异常IO引言输入、输出流分为字节流和字符流。Java的IO流使用一种装饰器设计模式，将IO流分为底层节点流和上层处理流。Java 7在java.nio新的IO API，称为NIO 2。Java对象的序列化机制，使用序列化机制可以把内存中的Java对象转换成二进制字节流，就可以把Java对象存储到磁盘里，或者在网络上传输Java对象。这是Java提供分布式编程的重要基础。 FileIO流对象序列化对象序列化（Serializable）：将一个对象编码成一个字节流。代价：一旦一个类被发布，就大大降低了“改变这个类的实现”的灵活性；增加了出现bug和安全漏洞的可能性；随着类发行新的版本，相关的测试负担也增加了。 类加载机制与反射https://www.cnblogs.com/whgk/p/6122036.htmlJava中获得Class对象通常三种方式： Class.forName(String className) 调用某个类的class属性来获取该类对应的Class对象。 调用某个对象的getClass()方法。 1和2都是直接根据类来取得该类的Class对象，相比之下，第二种优势： 代码更安全。编译阶段可以检查需要访问的Class对象是否存在。 程序性能更好。因无需调用方法。]]></content>
      <categories>
        <category>java</category>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML类图]]></title>
    <url>%2FUML%E7%B1%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[Unified Model Language（UML），统一建模语言。类图用于描述系统中所包含的类以及它们之间的相互关系，帮助人们简化对系统的理解，它是系统分析和设计阶段的重要产物，也是系统编码和测试的重要模型依据。 类表示类图分3层： 第一层表示类的名称，如果是抽象类，则用斜线表示； 第二层是类的特性，通常表示字段或属性； 第三层是类的操作，通常是方法或行为。 注：第二层与第三层前面存在符号，“+”代表public，“-”代表private，“#”代表protected。 类关系表示 关联（Association）：一种拥有的关系，它使一个类知道另一个类的属性和方法。UML中，关联关系采用带普通箭头的实心线表示，指向被拥有者。双向的关联可以有两个箭头或者没有箭头，单向关联有一个箭头。 聚合（Aggregation）：整体与部分的关系。成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。UML中，聚合关系采用带空心菱形的实心线表示，菱形指向整体，箭头指向部分。如：轮胎是汽车的组成部分，但是轮胎可以独立存在，因此，汽车和轮胎是聚合关系。 组合（Composition）：整体与部分的关系，但部分不能离开整体而单独存在。UML中，组合关系用带实心菱形的实心线表示，菱形指向整体，箭头指向部分。如：头与嘴巴就是组合关系。 依赖（Dependency）：使用关系。与管线关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化，依赖关系也可能发生变化。依赖也有方向，双向依赖是一种非常糟糕的结构，应该杜绝产生。UML中，依赖关系用带箭头的虚线表示，箭头指向被使用者，由依赖的一方指向被依赖的一方。 泛化（Generalization）：也就是继承关系。UML中，泛化关系用带空心三角形的直线来表示，三角形指向父类。 实现（Realization）：类与接口的关系。UML中，实现关系用带空心三角形的虚线来表示，三角形指向接口。 说明各种关系的强弱顺序：泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-历史版本]]></title>
    <url>%2Fjava-%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[简介JDK（Java SE Development Kit），Java标准版开发包。JRE（Java Runtime Environment），Java运行时环境。运行Java程序所必须环境的集合，包含JVM标准实现及Java核心类库。 JDK目录 bin：该路径存放了JDK的各种工具命令，javac、java等。 db：该路径安装Java DB的路径。 include：一些平台特定的头文件。 jre：运行Java程序所必需的JRE环境。 lib：存放JDK工具命令的实际执行程序 历史版本https://www.oracle.com/technetwork/java/javase/downloads/index.html Java 14（2020/3/17） Java 13（2019/9） Java 12 Java 11（2018/9/25）LTS长期支持2026年9月，Java 8以后的首个长期版本。 Java 10（2018/3/20） Java 9（2017/9） Java 8（2014/3/18） Java 7（2011/7/28） 2009/4/20，Oracle收购Sun Java SE 6（2006/12） Java 9 模块化 Java 8 Lambda表达式 Java 72011/7/28，Oracle发布Java SE 7，代号Dolphin（海豚） 引入二进制整数 支持字符串的switch语句 菱形语法 多异常捕捉 自动关闭资源的try语句 JDK 1.52004/10（改名为Java SE 5.0、Java EE和Java ME）泛型、增强的for语句、可变数量的形参、注释、自动拆箱和装箱等 Java发展简史 Sun公司在1995年年初发布了Java语言。 1996年初发布了JDK 1.0。这个版本包括两部分：运行环境（JRE）和开发环境（JDK）。 1997年2月18日发布了JDK 1.1。JDK 1.1增加了JIT（即时编译）编译器。JIT和传统的编译器不同，传统的编译器是编译一条，运行完后将其扔掉；而JIT会将经常用到的指令保存在内存中，当下次调用时就不需要重新编译了，通过这种方式让JDK在效率上有了较大提升。 一直以来，Java主要的应用就是网页上的Applet以及一些移动设备。到了1996年年底，Flash面世了。随后Flash增加了ActionScript编程脚本，Flash逐渐蚕食了Java在网页上的应用。 直到1998年12月，Sun发布了Java历史上最重要的JDK版本：JDK 1.2，伴随JDK 1.2一同发布的还有JSP/Servlet、EJB等规范，并将Java分成了J2EE、J2SE和J2ME三个版本。将API分成了三大类：核心API、可选API（补充，因平台的不同而不同）、特殊API。 J2EE：Java技术中应用最广泛的部分，J2EE提供了企业应用开发相关的完整解决方案。 J2SE：整个Java技术的核心和基础，它是J2ME和J2EE编程的基础。 J2ME：主要用于控制移动设备和信息家电等有限存储的设备。 2002年2月，Sun发布了JDK历史上最为成熟的版本：JDK 1.4。在此期间，Java语言在企业应用领域大放异彩，涌现出大量基于Java语言的开源框架：Struts、WebWork、Hibernate、Spring等；大量企业应用服务器也开始涌现：WebLogic、WebSphere、JBoss等。 2004年10月，Sun发布了万众期待的JDK 1.5，同时，Sun将JDK 1.5改名为Java SE 5.0，J2EE与J2ME改名为Java EE和Java ME。JDK 1.5增加了诸如泛型、增强的for语句、可变数量的形参、注释（Annotations）、自动拆箱和装箱等功能；同时，也发布了新的企业级平台规范，如通过注释等新特性来简化EJB的复杂性，并推出了EJB 3.0规范。还推出了自己的MVC框架规范：JSF，JSF规范类似于ASP.NET的服务器控件，通过它可以快速地构建复杂的JSP界面。 2006年12月，Sun发布了JDK 1.6（也被称为Java SE 6）。 2009年4月20日，Oracle收购Sun，获得了Java和Solaris。 2007年11月，Google宣布推出一款基于Linux平台的开源手机操作系统：Android。 2011年7月28日，Oracle发布了Java SE 7。引入了二进制整数、支持字符串的switch语句、菱形语法、多异常捕捉、自动关闭资源的try语句等新特性。 2014年3月18日，Oracle发布了Java SE 8，带来了全新的Lambda表达式。]]></content>
      <categories>
        <category>java</category>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio最强教程]]></title>
    <url>%2FAndroid-Studio%E6%9C%80%E5%BC%BA%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[工欲善其事，必先利其器。——《论语·卫灵公》 概览探索 Android Studio 基于Gradle的灵活构建系统 可针对所有Android设备进行开发的统一环境 Instant Run，可将变更推送到正在运行的应用，无需构建新的APK 丰富的测试工具和框架 C++和NDK支持 配置buildGradle 依赖项管理指南12345678910dependencies &#123; // Dependency on a local library module implementation project(":mylibrary") // Dependency on local binaries implementation fileTree(dir: 'libs', include: ['*.jar']) // Dependency on a remote binary implementation 'com.example.android:app-magic:12.3'&#125; Debug Show Execution Point Step Over：单步执行。如果当前行为方法调用（不会跳到方法内部），方法执行完后跳到下一行。 Step Into：与Step Over不同的是，会跳到方法内部（非类库的方法）。 Force Step Into：与Step Into不同的是，始终跳到方法内部。 Step Out：跳出方法，返回到该方法调用处。 Drop Frame Run to Cursor Resume Program：程序执行到下一个断点处。 Stop：停止调试。 变量观察 选中变量，右键选择Add to Watches 修改变量值，调试结果。选择Set Value 条件断点循环体内设置。 日志断点Suspend取消选中，显示日志输入框。 异常断点单击如下图标，在弹窗中新建异常断点。 变量断点方法断点在方法名所在行添加断点。 Plugins其他配置Logcat颜色Assert：#8F0005 深红Debug：#0070BB 蓝Error：#FF0006 红Info：#48BB31 绿Verbose：#BBBBBB 白Warning：#BBBB23 黄 Android Gradle plugin简介Android Gradle plugin12345678910111213141516buildscript &#123; repositories &#123; // Gradle 4.1 and higher include support for Google's Maven repo using // the google() method. And you need to include this repo to download // Android Gradle plugin 3.0.0 or higher. google() jcenter() ... &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:3.4.1' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125; The following table lists which version of Gradle is required for each version of the Android Gradle plugin. For the best performance, you should use the latest possible version of both Gradle and the plugin. Plugin version Gradle version Build Tools 1.0.0 - 1.1.3 2.2.1 - 2.3 1.2.0 - 1.3.1 2.2.1 - 2.9 1.5.0 2.2.1 - 2.13 2.0.0 - 2.1.2 2.10 - 2.13 2.1.3 - 2.2.3 2.14.1+ 2.3.0+ 3.3+ 3.0.0+ 4.1+ 26.0.2+ 3.1.0+ 4.4+ 3.2.0 - 3.2.1 4.6+ 3.3.0 - 3.3.2 4.10.1+ 3.4.0 - 3.4.1 5.1.1+ 3.5.0+ 5.4.1 - 5.6.4 3.5.0 (August 2019)This version of the Android plugin requires the following: Gradle 5.4.1 or higher. SDK Build Tools 28.0.3 or higher. 3.4.0 (April 2019)This version of the Android plugin requires the following: Gradle 5.1.1 or higher. SDK Build Tools 28.0.3 or higher. 3.3.0 (January 2019)3.2.0 (September 2018)3.1.0 (March 2018)3.0.0 (October 2017)This version of the Android plugin requires the following: Gradle 4.1 or higher. To learn more, read the section about updating Gradle. Build Tools 26.0.2 or higher. With this update, you no longer need to specify a version for the build tools—the plugin uses the minimum required version by default. So, you can now remove the android.buildToolsVersion property. Optimizations历史版本3.6（2020-2-25）3.5 (August 2019)3.5.1 (September 2019) system health, feature polish, and fixing bugs. Project Marble: Feature polish Apply Changes App deployment flow Improved Gradle sync and cache detection Improved build error output Project Upgrades Layout Editor Data Binding Improved support for C/C++ projects Build Variants panel improvements for single variant sync Side-by-side versions of the NDK Chrome OS Support Conditional delivery for dynamic feature modules IntelliJ IDEA 2019.1 Android Gradle plugin 3.5.0 updates 3.4 (April 2019)3.4.2 (July 2019)3.4.1 (May 2019)3.4.0 IntelliJ IDEA 2018.3.4 Android Gradle plugin 3.4.0 New Project Structure Dialog Variables Modules Dependencies Build Variants Suggestions New Resource Manager R8 enabled by default New intention action to quickly import dependencies R8gradle.properties可以做如下设置：1234# Disables R8 for Android Library modules only.android.enableR8.libraries = false# Disables R8 for all modules.android.enableR8 = false Note: For a given build type, if you set useProguard to false in your app module’s build.gradle file, the Android Gradle plugin uses R8 to shrink your app’s code for that build type, regardless of whether you disable R8 in your project’s gradle.properties file. 3.3 (January 2019) IntelliJ IDEA 2018.2.2 Delete unused Android Studio directories Lint improvements Create New Project wizard Profiler updates Automatic downloading of SDK components Support for Clang-Tidy CMake version 3.10.2 3.0 (October 2017) Android Plugin for Gradle 3.0.0 Kotlin support Java 8 language features support Android Profiler replaces the Android Monitor tool APK profiling and debugging Device File Explorer This replaces the filesystem tool available in DDMS. Instant Apps support Android Things modules 物联网设备上的应用开发 Adaptive Icons wizard Support for font resources URL intent-filter validator Preview for D8 DEX compiler Google’s Maven repository Android Studio 3.0 includes an optional new DEX compiler called D8. It will eventually replace the DX compiler, but you can opt-in to use the new D8 compiler now. Native debugging with Android Studio no longer supports 32-bit Windows.]]></content>
      <categories>
        <category>软件开发工具</category>
      </categories>
      <tags>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA最强教程]]></title>
    <url>%2FIntelliJ-IDEA%E6%9C%80%E5%BC%BA%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[工欲善其事，必先利其器。——《论语·卫灵公》 概述IDEA是JetBrains公司的产品，总部位于捷克共和国的首都布拉格。IDEA，全称IntelliJ IDEA，是java编程语言开发的集成环境。被业界公认为最好的java开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE支持、各类版本工具（git、svn等）、JUnit、代码分析、创新的GUI设计等。 IDEA版本： Ultimate（旗舰版，收费） Community（社区版，免费） 官方使用文档https://www.jetbrains.com/help/idea/meet-intellij-idea.html \IntelliJ IDEA 2018.3.5\bin中idea64.exe.vmoptions文件，修改内存大小配置。 设置 Editor -&gt; General 设置鼠标滚轮修改字体大小 设置鼠标悬浮提示 设置自动导包 添加方法分隔符 -&gt; Appearance 忽略大小写提示 -&gt; Code Completion 取消单行显示tabs操作 -&gt; Editor Tabs Editor -&gt; Color Scheme 设置主题 IDEA主题 设置注释颜色 -&gt; Language Defaults -&gt; Comments Editor -&gt; Code Style Editor -&gt; File and Code Templates：设置文件头部信息/*** @author 001* @date ${DATE}* @desc*/ Editor -&gt; File Encodings：设置项目文件编码UTF-8 Build, Execution, Deployment -&gt; Compiler：设置自动编译 File -&gt; Power Save Mode：设置为省电模式 快捷键（Keymap）自动代码快捷键Ctrl + J：显示代码模板列表Ctrl + Alt + I：自动缩进代码Ctrl + Alt + L：格式化代码Ctrl + Alt + M：选中代码，抽取方法Ctrl + Alt + O：优化导入的包Ctrl + Alt + T：选中代码，添加控制流（if{}else{}）Alt + Insert：生成代码（如get、set方法、构造方法等） 代码行快捷键Ctrl + D：复制行Ctrl + G：定位行Ctrl + X/Y：删除行Ctrl + Shift + up/down：代码向上/向下移动 查询快捷键Ctrl + B：查找变量的来源Ctrl + E：最近打开的文件Ctrl + F：当前窗口查找文本Ctrl + Shift + F：在指定窗口查找文本Ctrl + R：当前窗口替换文本Ctrl + Shift + R：在指定窗口替换文本Ctrl + N：查找类Ctrl + Shift + N：查找文件Ctrl + O：查看该类可以重写的方法Ctrl + Alt + B：查找所有的子类Ctrl + Alt + H：查看方法被调用的地方Ctrl + Alt + F7：选中字符在工程出现的地方Alt + Shift + C：查找修改的文件 注释快捷键Ctrl + /：单行注释Ctrl + Shift + /：多行注释/** + Enter：添加文档注释Ctrl + Q：显示注释文档 其他快捷键Alt + 1：隐藏或打开工程面板Alt + 左右方向键：切换当前面板的文件Ctrl + B：快速打开光标处的类/方法Ctrl + H：显示类结构图Ctrl + W：选中代码，连续按上下扩展Shift + F6：类/变量/方法重命名Ctrl + Shift + U：大小写切换 模板（Template）常用模板 File | Settings | Editor | Live Templates（可以自定义） File | Settings | Editor | General | Postfix Completion（不可以自定义） 输出 sout（输出） soutp（打印形参） soutm（”当前类名.当前方法名”） soutv（打印变量值） xxx.sout for循环 fori（普通for循环） iter（增强for循环） itar（普通for循环） list遍历 list.for（增强for循环） list.fori（普通for循环遍历） list.forr（倒序遍历） 条件判断 ifn（对象==null） inn（对象!=null） xxx.nn xxx.null private static final（prsf）public static final psf psfi（int类型） psfs（String类型） 修改psfi，Template text:12public static final int $VAR1$ = $VAR2$;$END$ 自定义模板 新建Template Group，如Custom 新建Live Template 1234567891011test:public void test$VAR1$() &#123; $VAR2$&#125;pric:/** * $VAR1$ */private int $VAR2$ = $VAR3$;$END$ DebugPluginshttps://plugins.jetbrains.com/ GsonFormat Lombok 其他 生成JavaDoc Tomcat 下载 http://tomcat.apache.org/ 配置环境变量 CATALINA_HOME（D:\swTools\apache-tomcat-8.5.38） Path（;%CATALINA_HOME%bin） 启动：Tomcat目录/bin/startup.bat 测试安装：http://localhost:8080/ 关联 Tomcat Server -&gt; Local 发布 生成war包，放到webapps目录中。 Tomcat的版本随着SUN公司推出的Servlet/JSP规范不同而不同，基本上是SUN公司每推出一个版本，Tomcat也会发行新的版本以适应新的规范。 Tomcat版本 Servlet/JSP规范 JDK版本 9.0 3.0 1.9 8.0 3.0 1.8 常见问题 JAVA_HOME环境变量没有配置，startup.bat启动会失败。 端口占用。\conf\server.xml Maven（Build Tools）Maven配置：File | Settings | Build, Execution, Deployment | Build Tools | Maven Maven home directory：Maven安装目录 User settings file：\conf\settings.xml，可以配置本地仓库目录，镜像（VPN） 123456789101112&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt; &lt;id&gt;repo2&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;repo2 maven&lt;/name&gt; &lt;url&gt;http://repo2.maven.org/maven2&lt;/url&gt;&lt;/mirror&gt; Local repository：settings.xml中配置本地仓库目录。 创建工程创建java项目创建Web项目New -&gt; Java -&gt; Web Application web/WEB-INF下创建两个文件夹：classes和lib Project Structure ——&gt; Modules ——&gt; Paths修改第一条路径 配置Tomcat容器 Tomcat中部署项目 编写index.jsp，运行Tomcat、 创建Maven项目New -&gt; Maven -&gt; Create form archetype -&gt; …webapp 历史版本https://www.jetbrains.com/idea/whatsnew/ 2018.3 (2019)https://www.jetbrains.com/idea/whatsnew/2018-3/]]></content>
      <categories>
        <category>软件开发工具</category>
      </categories>
      <tags>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记忆百科]]></title>
    <url>%2F%E8%AE%B0%E5%BF%86%E7%99%BE%E7%A7%91%2F</url>
    <content type="text"><![CDATA[软件版本 Alpha：内部测试版。找BUG，功能不全。 Beta：公开测试版。该阶段还会不断增加新功能。 RC：Release Candidate，候选版本。不再增加功能，多数开源软件会推出两个RC版本，最后的RC2则成为正式版本。 stable：稳定版。 软件版本命名规范第一种：主版本号.次版本号.修订版本号.日期加希腊字母版本号注意：希腊字母版本号共有五种，分别为base、alpha、beta、RC、release。如1.1.1.20181024_beta第二种：主版本号.次版本号.修订版本号 主版本号：当功能模块有较大的变动，如增加模块或整体架构发生变化。 次版本号：功能有一定的增加或变化。 修订版本号：bug修复。 软件开发工具 工具 说明 官网 IntelliJ IDEA 编码IDE https://www.jetbrains.com/idea/download Navicat 数据库管理工具 http://www.formysql.com/xiazai.html SQLyog 数据库管理工具 PowerDesigner 数据库设计 http://powerdesigner.de/ RedisDesktop redis客户端连接工具 https://redisdesktop.com/download Robomongo mongo客户端连接工具 https://robomongo.org/download Axure 原型设计 https://www.axure.com/ SwitchHosts 本地host管理 https://oldj.github.io/SwitchHosts/ X-shell Linux远程连接工具 http://www.netsarang.com/download/software.html MindMaster 思维导图设计 http://www.edrawsoft.cn/mindmaster ProcessOn 流程图绘制 https://www.processon.com/ ScreenToGif gif录制 https://www.screentogif.com/ PicPick 图片处理工具 https://picpick.app/zh/ Snipaste 屏幕截图工具 https://www.snipaste.com/ IT界三大定律 摩尔定律 反摩尔定律 安迪比尔定律What Andy gives, Bill takes away. 护眼色 色调：85；饱和度：123；亮度：205 R：199；G：237；B：204 色值：#C7EDCC]]></content>
      <categories>
        <category>综合</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F%E6%95%99%E7%A8%8B-Markdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[简介Markdown是一种轻量级的标记语言，将作者从繁杂的排版工作中解放出来，实现易读易写的文章写作。 Windows平台编辑器 MarkdownPad一款全功能的编辑器。 标题 #：H1 ##：H2 ###：H3 文本 加粗：文本左右分别添加两个* 斜体：文本左右分别添加一个* 加粗斜体：文本左右分别添加三个* 删除线：文本左右分别添加两个~ 文本颜色： 1&lt;font color="#ff0000"&gt;颜色文本&lt;/font&gt; 文本增加背景色：文本左右分别添加一个反引号 ` 引用在引用的文本前面添加&gt;，且可以嵌套，&gt;&gt;或&gt;&gt;&gt; 图片 Markdown显示图片语法： 1![图片说明](https://i.imgur.com/4u0hKYA.jpg) 效果如下图： 固定图片显示大小： 1&lt;img src="https://i.imgur.com/4u0hKYA.jpg" width=200 height=200 /&gt; 效果如下图： 图片按比例显示： 1&lt;img src="https://i.imgur.com/4u0hKYA.jpg" width=25% height=25% /&gt; 效果如下图： 链接Markdown显示连接语法：1[链接显示文本]（https://www.baidu.com） 列表 无序列表 有序列表：数字 + . + 空格 第一点 第二点 分隔线一行连续使用三个或以上的-或* 代码 每一行前面加一个tab或4个空格可以标记一个代码片段，效果如下图：public int main() { reutrn 0; } 连续三个反引号`（需要代码高亮的话，加上代码类型），键盘上数字1前面按键，如下图：效果如下图：12345public class main &#123; public static void main(String[] args)&#123; System.out.println("hello java"); &#125; &#125; 表格123|标题1|标题2|标题3||:---|:---:|---:||第一行第一列|01|第一行第三列| 注意：表格语句上一行必须为空行，否则表格无效。效果如下图： 标题1 标题2 标题3 第一行第一列 01 第一行第三列 说明： :-表示居左对齐；:-:表示居中对齐；-:表示居右对齐 -至少有一个 流程图]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客-Hexo-NexT主题配置]]></title>
    <url>%2F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-Hexo-NexT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[小序博客搭建，可以参考博文 个人博客-GitHub-PagesHexo的配置文件_config.yml分两种：站点配置文件、主题配置文件。站点配置文件参考Hexo，主题配置文件参考NexT本文主要讲解主题配置文件_config.yml（文件路径：hexo目录\themes\next\_config.yml）GitHub hexo-theme-next Site Information Settings设置站点信息favicon:修改网站图标，图片保存在目录\themes\next\source\images中。footer:站点底部 since:2018站点创建时间creative_commons:文章底部添加版权信息 Menu Settings 菜单项（名称和链接） 菜单项的显示文本 菜单项对应的图标。NexT使用的是Font Awesome提供的图标，Font Awesome提供了600+的图标，可以满足绝大多数的场景。 注意：菜单点击可能报Cannot GET **，创建page就可以了，命令如下：12// name为categories、tags、about等，文件存储路径为：root\sourcehexo new page &apos;name&apos; 在source目录下会生成菜单对应文件夹，修改文件夹中的index.md文件，新增type属性，如下：12345---title: 分类date: 2018-12-16 17:03:04type: &quot;categories&quot;--- Scheme SettingsScheme是NexT提供的一种特性，可以设置不同的外观。同时，几乎所有的配置都可以在Scheme之间共用。目前NexT支持以下几种Scheme: Muse-默认Scheme，NexT最初的版本，黑白色调，大量留白 Mist-Muse的紧凑版本，整洁有序的单栏外观 Pisces-双栏Scheme，小家碧玉似的清新 Gemini-左侧网站信息及目录，块+片段结构布局 Sidebar Settings设置侧栏 sidebar:侧栏的位置 sidebar:侧栏显示的时机 avatar:头像 social:社交链接 github_banner:（网站右上角显示关注GitHub图标） Blog rolls友情链接 toc:文章目录 Post Settings reward:打赏 wechat_subscriber:微信订阅 Third Party Services Settingslocal_search:网站添加搜索needmoreshare2:内容分享 在博客根目录执行如下命令： 1git clone https://github.com/theme-next/theme-next-needmoreshare2 themes/next/source/lib/needsharebutton 主题配置文件中，搜索needmoreshare2: 评论系统 畅言 官网 12345# changyanchangyan: enable: false appid: appkey: Valine 官网 DaoVoice修改文章内链接样式在文件\themes\next\source\css\_common\components\post\post.styl末尾，添加如下代码：1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; //原始链接颜色 border-bottom: none; border-bottom: 1px solid #0593d3; //底部分割线颜色 &amp;:hover &#123; color: #fc6423; //鼠标经过颜色 border-bottom: none; border-bottom: 1px solid #fc6423; //底部分割线颜色 &#125;&#125; 修改文章底部带#的标签实现效果图： \themes\next\layout_macro\post.swig中找到rel=”tag”&gt;#，将#替换为1&lt;i class="fa fa-tag"&gt;&lt;/i&gt; 文章末尾添加结束标语实现效果图： \themes\next\layout_macro中新建passage-end-tag.swig文件，添加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;-------------本文结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 打开\themes\next\layout_macro\post.swig文件，在post-body后，post-footer前，添加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 修改主题配置文件_config.yml，末尾添加如下内容： 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 网站底部添加总访客量、总访问量方法一： 打开\themes\next\layout_partials\footer.swig文件，在copyright之前添加如下代码：1&lt;script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 单个用户连续点击n篇文章，记录n次访问量。123&lt;span id="busuanzi_container_site_pv"&gt; 总访问量&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;次&lt;/span&gt; 单个用户连续点击n篇文章，只记录1次访客数。123&lt;span id="busuanzi_container_site_uv"&gt; 总访客数&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;人次&lt;/span&gt; 方法二：主题配置文件_config.yml，搜索busuanzi_count:注：本地预览时，数字存在异常，部署云端即可恢复正常。 网站底部添加字数统计npm install hexo-wordcount –save打开文件\themes\next\layout_partials\footer.swig，末尾加上如下代码：1234&lt;div class="theme-info"&gt; &lt;div class="powered-by"&gt;&lt;/div&gt; &lt;span class="post-count"&gt;全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 点击出现爱心效果 在目录\themes\next\source\js\src中新建文件love.js，添加如下代码： 1!function (e, t, a) &#123; function n() &#123; c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"), o(), r() &#125; function r() &#123; for (var e = 0; e &lt; d.length; e++)d[e].alpha &lt;= 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y-- , d[e].scale += .004, d[e].alpha -= .013, d[e].el.style.cssText = "left:" + d[e].x + "px;top:" + d[e].y + "px;opacity:" + d[e].alpha + ";transform:scale(" + d[e].scale + "," + d[e].scale + ") rotate(45deg);background:" + d[e].color + ";z-index:99999"); requestAnimationFrame(r) &#125; function o() &#123; var t = "function" == typeof e.onclick &amp;&amp; e.onclick; e.onclick = function (e) &#123; t &amp;&amp; t(), i(e) &#125; &#125; function i(e) &#123; var a = t.createElement("div"); a.className = "heart", d.push(&#123; el: a, x: e.clientX - 5, y: e.clientY - 5, scale: 1, alpha: 1, color: s() &#125;), t.body.appendChild(a) &#125; function c(e) &#123; var a = t.createElement("style"); a.type = "text/css"; try &#123; a.appendChild(t.createTextNode(e)) &#125; catch (t) &#123; a.styleSheet.cssText = e &#125; t.getElementsByTagName("head")[0].appendChild(a) &#125; function s() &#123; return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")" &#125; var d = []; e.requestAnimationFrame = function () &#123; return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) &#123; setTimeout(e, 1e3 / 60) &#125; &#125;(), n() &#125;(window, document); 打开文件\themes\next\layout_layout.swig，末尾加上如下代码： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 添加网易云音乐\themes\next\layout_macro\sidebar.swig 设置背景图片图片来源：https://source.unsplash.com打开文件themes\next\source\css_custom\custom.styl，添加如下代码：123456body &#123; background:url(https://source.unsplash.com/1600x900/daily?nature,water); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%;&#125; 添加依赖在目录\themes\next下，开启Git Bash，执行命令。 设置动态背景canvas_nest:1git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest 站点顶部进度条pace:1git clone https://github.com/theme-next/theme-next-pace source/lib/pace 参考https://theme-next.org/]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客-GitHub-Pages]]></title>
    <url>%2F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-GitHub-Pages%2F</url>
    <content type="text"><![CDATA[小序 创建GitHub Pages 安装Git 安装Node.js 安装hexo GitHub Pages 注册GitHub账号，新建仓库，仓库名格式为（用户名.github.io），用户名必须与GitHub保持一致。 仓库中点击Settings菜单，找到GitHub Pages Choose a theme HexoHexo是一个快速、简洁且高效的博客框架。使用Markdown解析文章，在几秒内，即可利用靓丽的主题生成静态网页。Windows搭建Hexo博客系统并部署到GitHub 安装hexo本地环境，使用命令：npm install -g hexo 计算机本地新建保存博客文件夹 初始化hexo博客工程：hexo init 执行编译与预览命令后，hexo预览http://localhost:4000/ 命令命令[hexo n “博客名称”] 新建博客 themes主题设置 博客根目录：git clone https://github.com/theme-next/hexo-theme-next themes/next 修改站点配置文件_config.yml中theme为目标主题名称 theme-NexT主题配置文件_config.yml scheme:目前NexT支持四种Scheme menu:设置菜单 sidebar:设置侧边栏 avatar:设置头像 favicon:设置网站缩略图 plugins 安装：npm install hexo-xxx –save 卸载：npm remove hexo-xxx –save hexo部署插件 npm install hexo-deployer-git –save 修改站点配置文件_config.yml，在deploy下指定仓库路径和部署的协议 hexo g hexo d hexo-adminnpm install hexo-admin –saveHexo Admin hexo-tocnpm install hexo-toc –save文章中添加目录，在站点配置文件_config.yml中，添加如下信息：12345678910# 文章顶部添加&lt;!-- toc --&gt;，会在标题下方生成文章目录。toc: maxdepth: 3 class: toc slugify: transliteration decodeEntities: false anchor: position: after symbol: &apos;&apos; style: header-anchor 注意坑：主题为NexT时，不要安装该插件，会导致sidebar中文章目录显示错误且不跳转。 jekylljekyll jekyll themes]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
